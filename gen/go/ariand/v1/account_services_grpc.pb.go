// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: ariand/v1/account_services.proto

package ariandv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AccountService_ListAccounts_FullMethodName        = "/ariand.v1.AccountService/ListAccounts"
	AccountService_GetAccount_FullMethodName          = "/ariand.v1.AccountService/GetAccount"
	AccountService_CreateAccount_FullMethodName       = "/ariand.v1.AccountService/CreateAccount"
	AccountService_UpdateAccount_FullMethodName       = "/ariand.v1.AccountService/UpdateAccount"
	AccountService_DeleteAccount_FullMethodName       = "/ariand.v1.AccountService/DeleteAccount"
	AccountService_SetAccountAnchor_FullMethodName    = "/ariand.v1.AccountService/SetAccountAnchor"
	AccountService_GetAccountBalance_FullMethodName   = "/ariand.v1.AccountService/GetAccountBalance"
	AccountService_GetAccountsCount_FullMethodName    = "/ariand.v1.AccountService/GetAccountsCount"
	AccountService_SyncAccountBalances_FullMethodName = "/ariand.v1.AccountService/SyncAccountBalances"
)

// AccountServiceClient is the client API for AccountService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Account management service
type AccountServiceClient interface {
	ListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error)
	GetAccount(ctx context.Context, in *GetAccountRequest, opts ...grpc.CallOption) (*GetAccountResponse, error)
	CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*CreateAccountResponse, error)
	UpdateAccount(ctx context.Context, in *UpdateAccountRequest, opts ...grpc.CallOption) (*UpdateAccountResponse, error)
	DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountResponse, error)
	SetAccountAnchor(ctx context.Context, in *SetAccountAnchorRequest, opts ...grpc.CallOption) (*SetAccountAnchorResponse, error)
	GetAccountBalance(ctx context.Context, in *GetAccountBalanceRequest, opts ...grpc.CallOption) (*GetAccountBalanceResponse, error)
	GetAccountsCount(ctx context.Context, in *GetAccountsCountRequest, opts ...grpc.CallOption) (*GetAccountsCountResponse, error)
	SyncAccountBalances(ctx context.Context, in *SyncAccountBalancesRequest, opts ...grpc.CallOption) (*SyncAccountBalancesResponse, error)
}

type accountServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountServiceClient(cc grpc.ClientConnInterface) AccountServiceClient {
	return &accountServiceClient{cc}
}

func (c *accountServiceClient) ListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAccountsResponse)
	err := c.cc.Invoke(ctx, AccountService_ListAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetAccount(ctx context.Context, in *GetAccountRequest, opts ...grpc.CallOption) (*GetAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAccountResponse)
	err := c.cc.Invoke(ctx, AccountService_GetAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*CreateAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAccountResponse)
	err := c.cc.Invoke(ctx, AccountService_CreateAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) UpdateAccount(ctx context.Context, in *UpdateAccountRequest, opts ...grpc.CallOption) (*UpdateAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAccountResponse)
	err := c.cc.Invoke(ctx, AccountService_UpdateAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAccountResponse)
	err := c.cc.Invoke(ctx, AccountService_DeleteAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) SetAccountAnchor(ctx context.Context, in *SetAccountAnchorRequest, opts ...grpc.CallOption) (*SetAccountAnchorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAccountAnchorResponse)
	err := c.cc.Invoke(ctx, AccountService_SetAccountAnchor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetAccountBalance(ctx context.Context, in *GetAccountBalanceRequest, opts ...grpc.CallOption) (*GetAccountBalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAccountBalanceResponse)
	err := c.cc.Invoke(ctx, AccountService_GetAccountBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetAccountsCount(ctx context.Context, in *GetAccountsCountRequest, opts ...grpc.CallOption) (*GetAccountsCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAccountsCountResponse)
	err := c.cc.Invoke(ctx, AccountService_GetAccountsCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) SyncAccountBalances(ctx context.Context, in *SyncAccountBalancesRequest, opts ...grpc.CallOption) (*SyncAccountBalancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncAccountBalancesResponse)
	err := c.cc.Invoke(ctx, AccountService_SyncAccountBalances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountServiceServer is the server API for AccountService service.
// All implementations should embed UnimplementedAccountServiceServer
// for forward compatibility.
//
// Account management service
type AccountServiceServer interface {
	ListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error)
	GetAccount(context.Context, *GetAccountRequest) (*GetAccountResponse, error)
	CreateAccount(context.Context, *CreateAccountRequest) (*CreateAccountResponse, error)
	UpdateAccount(context.Context, *UpdateAccountRequest) (*UpdateAccountResponse, error)
	DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountResponse, error)
	SetAccountAnchor(context.Context, *SetAccountAnchorRequest) (*SetAccountAnchorResponse, error)
	GetAccountBalance(context.Context, *GetAccountBalanceRequest) (*GetAccountBalanceResponse, error)
	GetAccountsCount(context.Context, *GetAccountsCountRequest) (*GetAccountsCountResponse, error)
	SyncAccountBalances(context.Context, *SyncAccountBalancesRequest) (*SyncAccountBalancesResponse, error)
}

// UnimplementedAccountServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAccountServiceServer struct{}

func (UnimplementedAccountServiceServer) ListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAccounts not implemented")
}
func (UnimplementedAccountServiceServer) GetAccount(context.Context, *GetAccountRequest) (*GetAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccount not implemented")
}
func (UnimplementedAccountServiceServer) CreateAccount(context.Context, *CreateAccountRequest) (*CreateAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccount not implemented")
}
func (UnimplementedAccountServiceServer) UpdateAccount(context.Context, *UpdateAccountRequest) (*UpdateAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAccount not implemented")
}
func (UnimplementedAccountServiceServer) DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccount not implemented")
}
func (UnimplementedAccountServiceServer) SetAccountAnchor(context.Context, *SetAccountAnchorRequest) (*SetAccountAnchorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAccountAnchor not implemented")
}
func (UnimplementedAccountServiceServer) GetAccountBalance(context.Context, *GetAccountBalanceRequest) (*GetAccountBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountBalance not implemented")
}
func (UnimplementedAccountServiceServer) GetAccountsCount(context.Context, *GetAccountsCountRequest) (*GetAccountsCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountsCount not implemented")
}
func (UnimplementedAccountServiceServer) SyncAccountBalances(context.Context, *SyncAccountBalancesRequest) (*SyncAccountBalancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncAccountBalances not implemented")
}
func (UnimplementedAccountServiceServer) testEmbeddedByValue() {}

// UnsafeAccountServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountServiceServer will
// result in compilation errors.
type UnsafeAccountServiceServer interface {
	mustEmbedUnimplementedAccountServiceServer()
}

func RegisterAccountServiceServer(s grpc.ServiceRegistrar, srv AccountServiceServer) {
	// If the following call pancis, it indicates UnimplementedAccountServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AccountService_ServiceDesc, srv)
}

func _AccountService_ListAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).ListAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountService_ListAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).ListAccounts(ctx, req.(*ListAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).GetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountService_GetAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).GetAccount(ctx, req.(*GetAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountService_CreateAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).CreateAccount(ctx, req.(*CreateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_UpdateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).UpdateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountService_UpdateAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).UpdateAccount(ctx, req.(*UpdateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).DeleteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountService_DeleteAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).DeleteAccount(ctx, req.(*DeleteAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_SetAccountAnchor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAccountAnchorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).SetAccountAnchor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountService_SetAccountAnchor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).SetAccountAnchor(ctx, req.(*SetAccountAnchorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_GetAccountBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).GetAccountBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountService_GetAccountBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).GetAccountBalance(ctx, req.(*GetAccountBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_GetAccountsCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountsCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).GetAccountsCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountService_GetAccountsCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).GetAccountsCount(ctx, req.(*GetAccountsCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_SyncAccountBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncAccountBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).SyncAccountBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountService_SyncAccountBalances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).SyncAccountBalances(ctx, req.(*SyncAccountBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AccountService_ServiceDesc is the grpc.ServiceDesc for AccountService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccountService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ariand.v1.AccountService",
	HandlerType: (*AccountServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAccounts",
			Handler:    _AccountService_ListAccounts_Handler,
		},
		{
			MethodName: "GetAccount",
			Handler:    _AccountService_GetAccount_Handler,
		},
		{
			MethodName: "CreateAccount",
			Handler:    _AccountService_CreateAccount_Handler,
		},
		{
			MethodName: "UpdateAccount",
			Handler:    _AccountService_UpdateAccount_Handler,
		},
		{
			MethodName: "DeleteAccount",
			Handler:    _AccountService_DeleteAccount_Handler,
		},
		{
			MethodName: "SetAccountAnchor",
			Handler:    _AccountService_SetAccountAnchor_Handler,
		},
		{
			MethodName: "GetAccountBalance",
			Handler:    _AccountService_GetAccountBalance_Handler,
		},
		{
			MethodName: "GetAccountsCount",
			Handler:    _AccountService_GetAccountsCount_Handler,
		},
		{
			MethodName: "SyncAccountBalances",
			Handler:    _AccountService_SyncAccountBalances_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ariand/v1/account_services.proto",
}

const (
	AccountCollaborationService_AddCollaborator_FullMethodName        = "/ariand.v1.AccountCollaborationService/AddCollaborator"
	AccountCollaborationService_RemoveCollaborator_FullMethodName     = "/ariand.v1.AccountCollaborationService/RemoveCollaborator"
	AccountCollaborationService_ListCollaborators_FullMethodName      = "/ariand.v1.AccountCollaborationService/ListCollaborators"
	AccountCollaborationService_ListUserCollaborations_FullMethodName = "/ariand.v1.AccountCollaborationService/ListUserCollaborations"
	AccountCollaborationService_LeaveCollaboration_FullMethodName     = "/ariand.v1.AccountCollaborationService/LeaveCollaboration"
	AccountCollaborationService_TransferOwnership_FullMethodName      = "/ariand.v1.AccountCollaborationService/TransferOwnership"
)

// AccountCollaborationServiceClient is the client API for AccountCollaborationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Account collaboration service
type AccountCollaborationServiceClient interface {
	AddCollaborator(ctx context.Context, in *AddCollaboratorRequest, opts ...grpc.CallOption) (*AddCollaboratorResponse, error)
	RemoveCollaborator(ctx context.Context, in *RemoveCollaboratorRequest, opts ...grpc.CallOption) (*RemoveCollaboratorResponse, error)
	ListCollaborators(ctx context.Context, in *ListCollaboratorsRequest, opts ...grpc.CallOption) (*ListCollaboratorsResponse, error)
	ListUserCollaborations(ctx context.Context, in *ListUserCollaborationsRequest, opts ...grpc.CallOption) (*ListUserCollaborationsResponse, error)
	LeaveCollaboration(ctx context.Context, in *LeaveCollaborationRequest, opts ...grpc.CallOption) (*LeaveCollaborationResponse, error)
	TransferOwnership(ctx context.Context, in *TransferOwnershipRequest, opts ...grpc.CallOption) (*TransferOwnershipResponse, error)
}

type accountCollaborationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountCollaborationServiceClient(cc grpc.ClientConnInterface) AccountCollaborationServiceClient {
	return &accountCollaborationServiceClient{cc}
}

func (c *accountCollaborationServiceClient) AddCollaborator(ctx context.Context, in *AddCollaboratorRequest, opts ...grpc.CallOption) (*AddCollaboratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddCollaboratorResponse)
	err := c.cc.Invoke(ctx, AccountCollaborationService_AddCollaborator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountCollaborationServiceClient) RemoveCollaborator(ctx context.Context, in *RemoveCollaboratorRequest, opts ...grpc.CallOption) (*RemoveCollaboratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveCollaboratorResponse)
	err := c.cc.Invoke(ctx, AccountCollaborationService_RemoveCollaborator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountCollaborationServiceClient) ListCollaborators(ctx context.Context, in *ListCollaboratorsRequest, opts ...grpc.CallOption) (*ListCollaboratorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCollaboratorsResponse)
	err := c.cc.Invoke(ctx, AccountCollaborationService_ListCollaborators_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountCollaborationServiceClient) ListUserCollaborations(ctx context.Context, in *ListUserCollaborationsRequest, opts ...grpc.CallOption) (*ListUserCollaborationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserCollaborationsResponse)
	err := c.cc.Invoke(ctx, AccountCollaborationService_ListUserCollaborations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountCollaborationServiceClient) LeaveCollaboration(ctx context.Context, in *LeaveCollaborationRequest, opts ...grpc.CallOption) (*LeaveCollaborationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeaveCollaborationResponse)
	err := c.cc.Invoke(ctx, AccountCollaborationService_LeaveCollaboration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountCollaborationServiceClient) TransferOwnership(ctx context.Context, in *TransferOwnershipRequest, opts ...grpc.CallOption) (*TransferOwnershipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferOwnershipResponse)
	err := c.cc.Invoke(ctx, AccountCollaborationService_TransferOwnership_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountCollaborationServiceServer is the server API for AccountCollaborationService service.
// All implementations should embed UnimplementedAccountCollaborationServiceServer
// for forward compatibility.
//
// Account collaboration service
type AccountCollaborationServiceServer interface {
	AddCollaborator(context.Context, *AddCollaboratorRequest) (*AddCollaboratorResponse, error)
	RemoveCollaborator(context.Context, *RemoveCollaboratorRequest) (*RemoveCollaboratorResponse, error)
	ListCollaborators(context.Context, *ListCollaboratorsRequest) (*ListCollaboratorsResponse, error)
	ListUserCollaborations(context.Context, *ListUserCollaborationsRequest) (*ListUserCollaborationsResponse, error)
	LeaveCollaboration(context.Context, *LeaveCollaborationRequest) (*LeaveCollaborationResponse, error)
	TransferOwnership(context.Context, *TransferOwnershipRequest) (*TransferOwnershipResponse, error)
}

// UnimplementedAccountCollaborationServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAccountCollaborationServiceServer struct{}

func (UnimplementedAccountCollaborationServiceServer) AddCollaborator(context.Context, *AddCollaboratorRequest) (*AddCollaboratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCollaborator not implemented")
}
func (UnimplementedAccountCollaborationServiceServer) RemoveCollaborator(context.Context, *RemoveCollaboratorRequest) (*RemoveCollaboratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCollaborator not implemented")
}
func (UnimplementedAccountCollaborationServiceServer) ListCollaborators(context.Context, *ListCollaboratorsRequest) (*ListCollaboratorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCollaborators not implemented")
}
func (UnimplementedAccountCollaborationServiceServer) ListUserCollaborations(context.Context, *ListUserCollaborationsRequest) (*ListUserCollaborationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserCollaborations not implemented")
}
func (UnimplementedAccountCollaborationServiceServer) LeaveCollaboration(context.Context, *LeaveCollaborationRequest) (*LeaveCollaborationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveCollaboration not implemented")
}
func (UnimplementedAccountCollaborationServiceServer) TransferOwnership(context.Context, *TransferOwnershipRequest) (*TransferOwnershipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferOwnership not implemented")
}
func (UnimplementedAccountCollaborationServiceServer) testEmbeddedByValue() {}

// UnsafeAccountCollaborationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountCollaborationServiceServer will
// result in compilation errors.
type UnsafeAccountCollaborationServiceServer interface {
	mustEmbedUnimplementedAccountCollaborationServiceServer()
}

func RegisterAccountCollaborationServiceServer(s grpc.ServiceRegistrar, srv AccountCollaborationServiceServer) {
	// If the following call pancis, it indicates UnimplementedAccountCollaborationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AccountCollaborationService_ServiceDesc, srv)
}

func _AccountCollaborationService_AddCollaborator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCollaboratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountCollaborationServiceServer).AddCollaborator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountCollaborationService_AddCollaborator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountCollaborationServiceServer).AddCollaborator(ctx, req.(*AddCollaboratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountCollaborationService_RemoveCollaborator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCollaboratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountCollaborationServiceServer).RemoveCollaborator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountCollaborationService_RemoveCollaborator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountCollaborationServiceServer).RemoveCollaborator(ctx, req.(*RemoveCollaboratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountCollaborationService_ListCollaborators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCollaboratorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountCollaborationServiceServer).ListCollaborators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountCollaborationService_ListCollaborators_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountCollaborationServiceServer).ListCollaborators(ctx, req.(*ListCollaboratorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountCollaborationService_ListUserCollaborations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserCollaborationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountCollaborationServiceServer).ListUserCollaborations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountCollaborationService_ListUserCollaborations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountCollaborationServiceServer).ListUserCollaborations(ctx, req.(*ListUserCollaborationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountCollaborationService_LeaveCollaboration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveCollaborationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountCollaborationServiceServer).LeaveCollaboration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountCollaborationService_LeaveCollaboration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountCollaborationServiceServer).LeaveCollaboration(ctx, req.(*LeaveCollaborationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountCollaborationService_TransferOwnership_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferOwnershipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountCollaborationServiceServer).TransferOwnership(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountCollaborationService_TransferOwnership_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountCollaborationServiceServer).TransferOwnership(ctx, req.(*TransferOwnershipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AccountCollaborationService_ServiceDesc is the grpc.ServiceDesc for AccountCollaborationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccountCollaborationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ariand.v1.AccountCollaborationService",
	HandlerType: (*AccountCollaborationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCollaborator",
			Handler:    _AccountCollaborationService_AddCollaborator_Handler,
		},
		{
			MethodName: "RemoveCollaborator",
			Handler:    _AccountCollaborationService_RemoveCollaborator_Handler,
		},
		{
			MethodName: "ListCollaborators",
			Handler:    _AccountCollaborationService_ListCollaborators_Handler,
		},
		{
			MethodName: "ListUserCollaborations",
			Handler:    _AccountCollaborationService_ListUserCollaborations_Handler,
		},
		{
			MethodName: "LeaveCollaboration",
			Handler:    _AccountCollaborationService_LeaveCollaboration_Handler,
		},
		{
			MethodName: "TransferOwnership",
			Handler:    _AccountCollaborationService_TransferOwnership_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ariand/v1/account_services.proto",
}
