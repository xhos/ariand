// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: receipts.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"google.golang.org/genproto/googleapis/type/date"
	"google.golang.org/genproto/googleapis/type/money"
)

type BulkCreateReceiptItemsParams struct {
	ReceiptID    int64            `json:"receipt_id"`
	LineNo       *int32           `json:"line_no"`
	Name         string           `json:"name"`
	Qty          *decimal.Decimal `json:"qty"`
	UnitPrice    *money.Money     `json:"unit_price"`
	LineTotal    *money.Money     `json:"line_total"`
	Sku          *string          `json:"sku"`
	CategoryHint *string          `json:"category_hint"`
}

const createReceipt = `-- name: CreateReceipt :one
INSERT INTO receipts (
  engine, parse_status, link_status, match_ids,
  merchant, purchase_date, total_amount, currency, tax_amount,
  raw_payload, canonical_data, image_url, image_sha256,
  lat, lon, location_source, location_label
) VALUES (
  $1::smallint,
  COALESCE($2::smallint, 1),
  COALESCE($3::smallint, 1),
  $4::bigint[],
  $5::text,
  $6::date,
  $7::numeric,
  $8::char(3),
  $9::numeric,
  $10::jsonb,
  $11::jsonb,
  $12::text,
  $13::bytea,
  $14::double precision,
  $15::double precision,
  $16::text,
  $17::text
)
RETURNING
  id, engine, parse_status, link_status, match_ids,
  merchant, purchase_date, total_amount, currency, tax_amount,
  raw_payload, canonical_data, image_url, image_sha256,
  lat, lon, location_source, location_label,
  created_at, updated_at
`

type CreateReceiptParams struct {
	Engine         int16            `json:"engine"`
	ParseStatus    *int16           `json:"parse_status"`
	LinkStatus     *int16           `json:"link_status"`
	MatchIds       []int64          `json:"match_ids"`
	Merchant       *string          `json:"merchant"`
	PurchaseDate   *date.Date       `json:"purchase_date"`
	TotalAmount    *decimal.Decimal `json:"total_amount"`
	Currency       *string          `json:"currency"`
	TaxAmount      *decimal.Decimal `json:"tax_amount"`
	RawPayload     []byte           `json:"raw_payload"`
	CanonicalData  []byte           `json:"canonical_data"`
	ImageUrl       *string          `json:"image_url"`
	ImageSha256    []byte           `json:"image_sha256"`
	Lat            *float64         `json:"lat"`
	Lon            *float64         `json:"lon"`
	LocationSource *string          `json:"location_source"`
	LocationLabel  *string          `json:"location_label"`
}

func (q *Queries) CreateReceipt(ctx context.Context, arg CreateReceiptParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, createReceipt,
		arg.Engine,
		arg.ParseStatus,
		arg.LinkStatus,
		arg.MatchIds,
		arg.Merchant,
		arg.PurchaseDate,
		arg.TotalAmount,
		arg.Currency,
		arg.TaxAmount,
		arg.RawPayload,
		arg.CanonicalData,
		arg.ImageUrl,
		arg.ImageSha256,
		arg.Lat,
		arg.Lon,
		arg.LocationSource,
		arg.LocationLabel,
	)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.Engine,
		&i.ParseStatus,
		&i.LinkStatus,
		&i.MatchIds,
		&i.Merchant,
		&i.PurchaseDate,
		&i.TotalAmount,
		&i.Currency,
		&i.TaxAmount,
		&i.RawPayload,
		&i.CanonicalData,
		&i.ImageUrl,
		&i.ImageSha256,
		&i.Lat,
		&i.Lon,
		&i.LocationSource,
		&i.LocationLabel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createReceiptItem = `-- name: CreateReceiptItem :one
INSERT INTO receipt_items (
  receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint
) VALUES (
  $1::bigint,
  $2::int,
  $3::text,
  COALESCE($4::numeric, 1),
  $5::numeric,
  $6::numeric,
  $7::text,
  $8::text
)
RETURNING id, receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint,
          created_at, updated_at
`

type CreateReceiptItemParams struct {
	ReceiptID    int64            `json:"receipt_id"`
	LineNo       *int32           `json:"line_no"`
	Name         string           `json:"name"`
	Qty          *decimal.Decimal `json:"qty"`
	UnitPrice    *decimal.Decimal `json:"unit_price"`
	LineTotal    *decimal.Decimal `json:"line_total"`
	Sku          *string          `json:"sku"`
	CategoryHint *string          `json:"category_hint"`
}

func (q *Queries) CreateReceiptItem(ctx context.Context, arg CreateReceiptItemParams) (ReceiptItem, error) {
	row := q.db.QueryRow(ctx, createReceiptItem,
		arg.ReceiptID,
		arg.LineNo,
		arg.Name,
		arg.Qty,
		arg.UnitPrice,
		arg.LineTotal,
		arg.Sku,
		arg.CategoryHint,
	)
	var i ReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.LineNo,
		&i.Name,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.Sku,
		&i.CategoryHint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReceiptForUser = `-- name: DeleteReceiptForUser :execrows
DELETE FROM receipts 
WHERE id = $1::bigint
  AND EXISTS (
    SELECT 1 FROM transactions t
    JOIN accounts a ON t.account_id = a.id
    LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $2::uuid
    WHERE t.receipt_id = receipts.id
      AND (a.owner_id = $2::uuid OR au.user_id IS NOT NULL)
  )
`

type DeleteReceiptForUserParams struct {
	ID     int64     `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteReceiptForUser(ctx context.Context, arg DeleteReceiptForUserParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReceiptForUser, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteReceiptItem = `-- name: DeleteReceiptItem :execrows
DELETE FROM receipt_items WHERE id = $1::bigint
`

func (q *Queries) DeleteReceiptItem(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReceiptItem, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteReceiptItemsByReceipt = `-- name: DeleteReceiptItemsByReceipt :execrows
DELETE FROM receipt_items WHERE receipt_id = $1::bigint
`

func (q *Queries) DeleteReceiptItemsByReceipt(ctx context.Context, receiptID int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReceiptItemsByReceipt, receiptID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findCandidateTransactions = `-- name: FindCandidateTransactions :many
SELECT id, account_id, tx_date, tx_amount, tx_currency, tx_desc, merchant
FROM transactions
WHERE tx_amount BETWEEN $1::numeric AND $2::numeric
  AND tx_date BETWEEN $3::timestamptz AND $4::timestamptz
  AND receipt_id IS NULL  -- not already linked
ORDER BY ABS(tx_amount - $5::numeric), ABS(EXTRACT(EPOCH FROM (tx_date - $6::timestamptz))) / 86400
`

type FindCandidateTransactionsParams struct {
	MinAmount    decimal.Decimal `json:"min_amount"`
	MaxAmount    decimal.Decimal `json:"max_amount"`
	StartDate    time.Time       `json:"start_date"`
	EndDate      time.Time       `json:"end_date"`
	TargetAmount decimal.Decimal `json:"target_amount"`
	TargetDate   time.Time       `json:"target_date"`
}

type FindCandidateTransactionsRow struct {
	ID         int64        `json:"id"`
	AccountID  int64        `json:"account_id"`
	TxDate     time.Time    `json:"tx_date"`
	TxAmount   *money.Money `json:"tx_amount"`
	TxCurrency string       `json:"tx_currency"`
	TxDesc     *string      `json:"tx_desc"`
	Merchant   *string      `json:"merchant"`
}

func (q *Queries) FindCandidateTransactions(ctx context.Context, arg FindCandidateTransactionsParams) ([]FindCandidateTransactionsRow, error) {
	rows, err := q.db.Query(ctx, findCandidateTransactions,
		arg.MinAmount,
		arg.MaxAmount,
		arg.StartDate,
		arg.EndDate,
		arg.TargetAmount,
		arg.TargetDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCandidateTransactionsRow
	for rows.Next() {
		var i FindCandidateTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TxDate,
			&i.TxAmount,
			&i.TxCurrency,
			&i.TxDesc,
			&i.Merchant,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReceipt = `-- name: GetReceipt :one
SELECT
  id, engine, parse_status, link_status, match_ids,
  merchant, purchase_date, total_amount, currency, tax_amount,
  raw_payload, canonical_data, image_url, image_sha256,
  lat, lon, location_source, location_label,
  created_at, updated_at
FROM receipts
WHERE id = $1::bigint
`

func (q *Queries) GetReceipt(ctx context.Context, id int64) (Receipt, error) {
	row := q.db.QueryRow(ctx, getReceipt, id)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.Engine,
		&i.ParseStatus,
		&i.LinkStatus,
		&i.MatchIds,
		&i.Merchant,
		&i.PurchaseDate,
		&i.TotalAmount,
		&i.Currency,
		&i.TaxAmount,
		&i.RawPayload,
		&i.CanonicalData,
		&i.ImageUrl,
		&i.ImageSha256,
		&i.Lat,
		&i.Lon,
		&i.LocationSource,
		&i.LocationLabel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReceiptForUser = `-- name: GetReceiptForUser :one
SELECT DISTINCT
  r.id, r.engine, r.parse_status, r.link_status, r.match_ids,
  r.merchant, r.purchase_date, r.total_amount, r.currency, r.tax_amount,
  r.raw_payload, r.canonical_data, r.image_url, r.image_sha256,
  r.lat, r.lon, r.location_source, r.location_label,
  r.created_at, r.updated_at
FROM receipts r
LEFT JOIN transactions t ON r.id = t.receipt_id
LEFT JOIN accounts a ON t.account_id = a.id
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
WHERE r.id = $2::bigint
  AND (a.owner_id = $1::uuid OR au.user_id IS NOT NULL)
`

type GetReceiptForUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     int64     `json:"id"`
}

func (q *Queries) GetReceiptForUser(ctx context.Context, arg GetReceiptForUserParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, getReceiptForUser, arg.UserID, arg.ID)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.Engine,
		&i.ParseStatus,
		&i.LinkStatus,
		&i.MatchIds,
		&i.Merchant,
		&i.PurchaseDate,
		&i.TotalAmount,
		&i.Currency,
		&i.TaxAmount,
		&i.RawPayload,
		&i.CanonicalData,
		&i.ImageUrl,
		&i.ImageSha256,
		&i.Lat,
		&i.Lon,
		&i.LocationSource,
		&i.LocationLabel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReceiptItem = `-- name: GetReceiptItem :one
SELECT
  id, receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint,
  created_at, updated_at
FROM receipt_items
WHERE id = $1::bigint
`

func (q *Queries) GetReceiptItem(ctx context.Context, id int64) (ReceiptItem, error) {
	row := q.db.QueryRow(ctx, getReceiptItem, id)
	var i ReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.LineNo,
		&i.Name,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.Sku,
		&i.CategoryHint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReceiptMatchCandidates = `-- name: GetReceiptMatchCandidates :many
SELECT r.id, r.merchant, r.purchase_date, r.total_amount, r.currency,
       COUNT(t.id) AS potential_matches
FROM receipts r
LEFT JOIN transactions t ON t.id = ANY(r.match_ids)
WHERE r.link_status = 3  -- needs verification
GROUP BY r.id, r.merchant, r.purchase_date, r.total_amount, r.currency
ORDER BY r.created_at DESC
`

type GetReceiptMatchCandidatesRow struct {
	ID               int64        `json:"id"`
	Merchant         *string      `json:"merchant"`
	PurchaseDate     *date.Date   `json:"purchase_date"`
	TotalAmount      *money.Money `json:"total_amount"`
	Currency         *string      `json:"currency"`
	PotentialMatches int64        `json:"potential_matches"`
}

func (q *Queries) GetReceiptMatchCandidates(ctx context.Context) ([]GetReceiptMatchCandidatesRow, error) {
	rows, err := q.db.Query(ctx, getReceiptMatchCandidates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReceiptMatchCandidatesRow
	for rows.Next() {
		var i GetReceiptMatchCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Merchant,
			&i.PurchaseDate,
			&i.TotalAmount,
			&i.Currency,
			&i.PotentialMatches,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnlinkedReceipts = `-- name: GetUnlinkedReceipts :many
SELECT id, merchant, purchase_date, total_amount, currency, created_at
FROM receipts
WHERE link_status = 1  -- unlinked
ORDER BY created_at DESC
LIMIT COALESCE($1::int, 50)
`

type GetUnlinkedReceiptsRow struct {
	ID           int64        `json:"id"`
	Merchant     *string      `json:"merchant"`
	PurchaseDate *date.Date   `json:"purchase_date"`
	TotalAmount  *money.Money `json:"total_amount"`
	Currency     *string      `json:"currency"`
	CreatedAt    time.Time    `json:"created_at"`
}

// Utility queries
func (q *Queries) GetUnlinkedReceipts(ctx context.Context, limit *int32) ([]GetUnlinkedReceiptsRow, error) {
	rows, err := q.db.Query(ctx, getUnlinkedReceipts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnlinkedReceiptsRow
	for rows.Next() {
		var i GetUnlinkedReceiptsRow
		if err := rows.Scan(
			&i.ID,
			&i.Merchant,
			&i.PurchaseDate,
			&i.TotalAmount,
			&i.Currency,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkTransactionToReceipt = `-- name: LinkTransactionToReceipt :exec
UPDATE transactions 
SET receipt_id = $1::bigint
WHERE id = $2::bigint
  AND receipt_id IS NULL
`

type LinkTransactionToReceiptParams struct {
	ReceiptID     int64 `json:"receipt_id"`
	TransactionID int64 `json:"transaction_id"`
}

func (q *Queries) LinkTransactionToReceipt(ctx context.Context, arg LinkTransactionToReceiptParams) error {
	_, err := q.db.Exec(ctx, linkTransactionToReceipt, arg.ReceiptID, arg.TransactionID)
	return err
}

const listReceiptItemsForReceipt = `-- name: ListReceiptItemsForReceipt :many
SELECT
  id, receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint,
  created_at, updated_at
FROM receipt_items
WHERE receipt_id = $1::bigint
ORDER BY line_no NULLS LAST, id
`

// Receipt Items CRUD
func (q *Queries) ListReceiptItemsForReceipt(ctx context.Context, receiptID int64) ([]ReceiptItem, error) {
	rows, err := q.db.Query(ctx, listReceiptItemsForReceipt, receiptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReceiptItem
	for rows.Next() {
		var i ReceiptItem
		if err := rows.Scan(
			&i.ID,
			&i.ReceiptID,
			&i.LineNo,
			&i.Name,
			&i.Qty,
			&i.UnitPrice,
			&i.LineTotal,
			&i.Sku,
			&i.CategoryHint,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReceiptsForUser = `-- name: ListReceiptsForUser :many
SELECT DISTINCT
  r.id, r.engine, r.parse_status, r.link_status, r.match_ids,
  r.merchant, r.purchase_date, r.total_amount, r.currency, r.tax_amount,
  r.raw_payload, r.canonical_data, r.image_url, r.image_sha256,
  r.lat, r.lon, r.location_source, r.location_label,
  r.created_at, r.updated_at
FROM receipts r
LEFT JOIN transactions t ON r.id = t.receipt_id
LEFT JOIN accounts a ON t.account_id = a.id
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
WHERE a.owner_id = $1::uuid OR au.user_id IS NOT NULL
ORDER BY r.created_at DESC
`

func (q *Queries) ListReceiptsForUser(ctx context.Context, userID uuid.UUID) ([]Receipt, error) {
	rows, err := q.db.Query(ctx, listReceiptsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Receipt
	for rows.Next() {
		var i Receipt
		if err := rows.Scan(
			&i.ID,
			&i.Engine,
			&i.ParseStatus,
			&i.LinkStatus,
			&i.MatchIds,
			&i.Merchant,
			&i.PurchaseDate,
			&i.TotalAmount,
			&i.Currency,
			&i.TaxAmount,
			&i.RawPayload,
			&i.CanonicalData,
			&i.ImageUrl,
			&i.ImageSha256,
			&i.Lat,
			&i.Lon,
			&i.LocationSource,
			&i.LocationLabel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReceipt = `-- name: UpdateReceipt :execrows
UPDATE receipts
SET engine = COALESCE($1::smallint, engine),
    parse_status = COALESCE($2::smallint, parse_status),
    link_status = COALESCE($3::smallint, link_status),
    match_ids = COALESCE($4::bigint[], match_ids),
    merchant = COALESCE($5::text, merchant),
    purchase_date = COALESCE($6::date, purchase_date),
    total_amount = COALESCE($7::numeric, total_amount),
    currency = COALESCE($8::char(3), currency),
    tax_amount = COALESCE($9::numeric, tax_amount),
    raw_payload = COALESCE($10::jsonb, raw_payload),
    canonical_data = COALESCE($11::jsonb, canonical_data),
    image_url = COALESCE($12::text, image_url),
    image_sha256 = COALESCE($13::bytea, image_sha256),
    lat = COALESCE($14::double precision, lat),
    lon = COALESCE($15::double precision, lon),
    location_source = COALESCE($16::text, location_source),
    location_label = COALESCE($17::text, location_label)
WHERE id = $18::bigint
`

type UpdateReceiptParams struct {
	Engine         *int16           `json:"engine"`
	ParseStatus    *int16           `json:"parse_status"`
	LinkStatus     *int16           `json:"link_status"`
	MatchIds       []int64          `json:"match_ids"`
	Merchant       *string          `json:"merchant"`
	PurchaseDate   *date.Date       `json:"purchase_date"`
	TotalAmount    *decimal.Decimal `json:"total_amount"`
	Currency       *string          `json:"currency"`
	TaxAmount      *decimal.Decimal `json:"tax_amount"`
	RawPayload     []byte           `json:"raw_payload"`
	CanonicalData  []byte           `json:"canonical_data"`
	ImageUrl       *string          `json:"image_url"`
	ImageSha256    []byte           `json:"image_sha256"`
	Lat            *float64         `json:"lat"`
	Lon            *float64         `json:"lon"`
	LocationSource *string          `json:"location_source"`
	LocationLabel  *string          `json:"location_label"`
	ID             int64            `json:"id"`
}

func (q *Queries) UpdateReceipt(ctx context.Context, arg UpdateReceiptParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateReceipt,
		arg.Engine,
		arg.ParseStatus,
		arg.LinkStatus,
		arg.MatchIds,
		arg.Merchant,
		arg.PurchaseDate,
		arg.TotalAmount,
		arg.Currency,
		arg.TaxAmount,
		arg.RawPayload,
		arg.CanonicalData,
		arg.ImageUrl,
		arg.ImageSha256,
		arg.Lat,
		arg.Lon,
		arg.LocationSource,
		arg.LocationLabel,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateReceiptItem = `-- name: UpdateReceiptItem :one
UPDATE receipt_items
SET line_no = COALESCE($1::int, line_no),
    name = COALESCE($2::text, name),
    qty = COALESCE($3::numeric, qty),
    unit_price = COALESCE($4::numeric, unit_price),
    line_total = COALESCE($5::numeric, line_total),
    sku = COALESCE($6::text, sku),
    category_hint = COALESCE($7::text, category_hint)
WHERE id = $8::bigint
RETURNING id, receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint,
          created_at, updated_at
`

type UpdateReceiptItemParams struct {
	LineNo       *int32           `json:"line_no"`
	Name         *string          `json:"name"`
	Qty          *decimal.Decimal `json:"qty"`
	UnitPrice    *decimal.Decimal `json:"unit_price"`
	LineTotal    *decimal.Decimal `json:"line_total"`
	Sku          *string          `json:"sku"`
	CategoryHint *string          `json:"category_hint"`
	ID           int64            `json:"id"`
}

func (q *Queries) UpdateReceiptItem(ctx context.Context, arg UpdateReceiptItemParams) (ReceiptItem, error) {
	row := q.db.QueryRow(ctx, updateReceiptItem,
		arg.LineNo,
		arg.Name,
		arg.Qty,
		arg.UnitPrice,
		arg.LineTotal,
		arg.Sku,
		arg.CategoryHint,
		arg.ID,
	)
	var i ReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.LineNo,
		&i.Name,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.Sku,
		&i.CategoryHint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
