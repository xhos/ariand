// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: receipts.sql

package sqlc

import (
	"context"
	"time"

	"ariand/internal/types"
	"github.com/google/uuid"
)

type BulkCreateReceiptItemsParams struct {
	ReceiptID    int64        `db:"receipt_id" json:"receipt_id"`
	LineNo       *int32       `db:"line_no" json:"line_no"`
	Name         string       `db:"name" json:"name"`
	Qty          *int32       `db:"qty" json:"qty"`
	UnitPrice    *types.Money `db:"unit_price" json:"unit_price"`
	LineTotal    *types.Money `db:"line_total" json:"line_total"`
	Sku          *string      `db:"sku" json:"sku"`
	CategoryHint *string      `db:"category_hint" json:"category_hint"`
}

const createReceipt = `-- name: CreateReceipt :one
insert into
  receipts (
    engine,
    parse_status,
    link_status,
    match_ids,
    merchant,
    purchase_date,
    total_amount,
    tax_amount,
    raw_payload,
    canonical_data,
    image_url,
    image_sha256,
    lat,
    lon,
    location_source,
    location_label
  )
values
  (
    $1::smallint,
    COALESCE($2::smallint, 1),
    COALESCE($3::smallint, 1),
    $4::bigint [],
    $5::text,
    $6::date,
    $7::jsonb,
    $8::jsonb,
    $9::jsonb,
    $10::jsonb,
    $11::text,
    $12::bytea,
    $13::double precision,
    $14::double precision,
    $15::text,
    $16::text
  )
returning
  id,
  engine,
  parse_status,
  link_status,
  match_ids,
  merchant,
  purchase_date,
  total_amount,
  tax_amount,
  raw_payload,
  canonical_data,
  image_url,
  image_sha256,
  lat,
  lon,
  location_source,
  location_label,
  created_at,
  updated_at
`

type CreateReceiptParams struct {
	Engine         int16      `db:"engine" json:"engine"`
	ParseStatus    *int16     `db:"parse_status" json:"parse_status"`
	LinkStatus     *int16     `db:"link_status" json:"link_status"`
	MatchIds       []int64    `db:"match_ids" json:"match_ids"`
	Merchant       *string    `db:"merchant" json:"merchant"`
	PurchaseDate   *time.Time `db:"purchase_date" json:"purchase_date"`
	TotalAmount    []byte     `db:"total_amount" json:"total_amount"`
	TaxAmount      []byte     `db:"tax_amount" json:"tax_amount"`
	RawPayload     []byte     `db:"raw_payload" json:"raw_payload"`
	CanonicalData  []byte     `db:"canonical_data" json:"canonical_data"`
	ImageUrl       *string    `db:"image_url" json:"image_url"`
	ImageSha256    []byte     `db:"image_sha256" json:"image_sha256"`
	Lat            *float64   `db:"lat" json:"lat"`
	Lon            *float64   `db:"lon" json:"lon"`
	LocationSource *string    `db:"location_source" json:"location_source"`
	LocationLabel  *string    `db:"location_label" json:"location_label"`
}

func (q *Queries) CreateReceipt(ctx context.Context, arg CreateReceiptParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, createReceipt,
		arg.Engine,
		arg.ParseStatus,
		arg.LinkStatus,
		arg.MatchIds,
		arg.Merchant,
		arg.PurchaseDate,
		arg.TotalAmount,
		arg.TaxAmount,
		arg.RawPayload,
		arg.CanonicalData,
		arg.ImageUrl,
		arg.ImageSha256,
		arg.Lat,
		arg.Lon,
		arg.LocationSource,
		arg.LocationLabel,
	)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.Engine,
		&i.ParseStatus,
		&i.LinkStatus,
		&i.MatchIds,
		&i.Merchant,
		&i.PurchaseDate,
		&i.TotalAmount,
		&i.TaxAmount,
		&i.RawPayload,
		&i.CanonicalData,
		&i.ImageUrl,
		&i.ImageSha256,
		&i.Lat,
		&i.Lon,
		&i.LocationSource,
		&i.LocationLabel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createReceiptItem = `-- name: CreateReceiptItem :one
insert into
  receipt_items (
    receipt_id,
    line_no,
    name,
    qty,
    unit_price,
    line_total,
    sku,
    category_hint
  )
values
  (
    $1::bigint,
    $2::int,
    $3::text,
    COALESCE($4::int, 1),
    $5::jsonb,
    $6::jsonb,
    $7::text,
    $8::text
  )
returning
  id,
  receipt_id,
  line_no,
  name,
  qty,
  unit_price,
  line_total,
  sku,
  category_hint,
  created_at,
  updated_at
`

type CreateReceiptItemParams struct {
	ReceiptID    int64   `db:"receipt_id" json:"receipt_id"`
	LineNo       *int32  `db:"line_no" json:"line_no"`
	Name         string  `db:"name" json:"name"`
	Qty          *int32  `db:"qty" json:"qty"`
	UnitPrice    []byte  `db:"unit_price" json:"unit_price"`
	LineTotal    []byte  `db:"line_total" json:"line_total"`
	Sku          *string `db:"sku" json:"sku"`
	CategoryHint *string `db:"category_hint" json:"category_hint"`
}

func (q *Queries) CreateReceiptItem(ctx context.Context, arg CreateReceiptItemParams) (ReceiptItem, error) {
	row := q.db.QueryRow(ctx, createReceiptItem,
		arg.ReceiptID,
		arg.LineNo,
		arg.Name,
		arg.Qty,
		arg.UnitPrice,
		arg.LineTotal,
		arg.Sku,
		arg.CategoryHint,
	)
	var i ReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.LineNo,
		&i.Name,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.Sku,
		&i.CategoryHint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReceipt = `-- name: DeleteReceipt :execrows
delete from
  receipts
where
  id = $1::bigint
  and exists (
    select
      1
    from
      transactions t
      join accounts a on t.account_id = a.id
      left join account_users au on a.id = au.account_id
      and au.user_id = $2::uuid
    where
      t.receipt_id = receipts.id
      and (
        a.owner_id = $2::uuid
        or au.user_id is not null
      )
  )
`

type DeleteReceiptParams struct {
	ID     int64     `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteReceipt(ctx context.Context, arg DeleteReceiptParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReceipt, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteReceiptItem = `-- name: DeleteReceiptItem :execrows
delete from
  receipt_items
where
  id = $1::bigint
`

func (q *Queries) DeleteReceiptItem(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReceiptItem, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteReceiptItemsByReceipt = `-- name: DeleteReceiptItemsByReceipt :execrows
delete from
  receipt_items
where
  receipt_id = $1::bigint
`

func (q *Queries) DeleteReceiptItemsByReceipt(ctx context.Context, receiptID int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReceiptItemsByReceipt, receiptID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getReceipt = `-- name: GetReceipt :one
select
  distinct r.id,
  r.engine,
  r.parse_status,
  r.link_status,
  r.match_ids,
  r.merchant,
  r.purchase_date,
  r.total_amount,
  r.tax_amount,
  r.raw_payload,
  r.canonical_data,
  r.image_url,
  r.image_sha256,
  r.lat,
  r.lon,
  r.location_source,
  r.location_label,
  r.created_at,
  r.updated_at
from
  receipts r
  left join transactions t on r.id = t.receipt_id
  left join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  r.id = $2::bigint
  and (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
`

type GetReceiptParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	ID     int64     `db:"id" json:"id"`
}

func (q *Queries) GetReceipt(ctx context.Context, arg GetReceiptParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, getReceipt, arg.UserID, arg.ID)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.Engine,
		&i.ParseStatus,
		&i.LinkStatus,
		&i.MatchIds,
		&i.Merchant,
		&i.PurchaseDate,
		&i.TotalAmount,
		&i.TaxAmount,
		&i.RawPayload,
		&i.CanonicalData,
		&i.ImageUrl,
		&i.ImageSha256,
		&i.Lat,
		&i.Lon,
		&i.LocationSource,
		&i.LocationLabel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReceiptItem = `-- name: GetReceiptItem :one
select
  id,
  receipt_id,
  line_no,
  name,
  qty,
  unit_price,
  line_total,
  sku,
  category_hint,
  created_at,
  updated_at
from
  receipt_items
where
  id = $1::bigint
`

func (q *Queries) GetReceiptItem(ctx context.Context, id int64) (ReceiptItem, error) {
	row := q.db.QueryRow(ctx, getReceiptItem, id)
	var i ReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.LineNo,
		&i.Name,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.Sku,
		&i.CategoryHint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReceiptMatchCandidates = `-- name: GetReceiptMatchCandidates :many
select
  r.id,
  r.merchant,
  r.purchase_date,
  r.total_amount,
  COUNT(t.id) as potential_matches
from
  receipts r
  left join transactions t on t.id = ANY(r.match_ids)
where
  r.link_status = 3 -- needs verification
group by
  r.id,
  r.merchant,
  r.purchase_date,
  r.total_amount
order by
  r.created_at desc
`

type GetReceiptMatchCandidatesRow struct {
	ID               int64        `db:"id" json:"id"`
	Merchant         *string      `db:"merchant" json:"merchant"`
	PurchaseDate     *time.Time   `db:"purchase_date" json:"purchase_date"`
	TotalAmount      *types.Money `db:"total_amount" json:"total_amount"`
	PotentialMatches int64        `db:"potential_matches" json:"potential_matches"`
}

func (q *Queries) GetReceiptMatchCandidates(ctx context.Context) ([]GetReceiptMatchCandidatesRow, error) {
	rows, err := q.db.Query(ctx, getReceiptMatchCandidates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReceiptMatchCandidatesRow
	for rows.Next() {
		var i GetReceiptMatchCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Merchant,
			&i.PurchaseDate,
			&i.TotalAmount,
			&i.PotentialMatches,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnlinkedReceipts = `-- name: GetUnlinkedReceipts :many
select
  id, engine, parse_status, link_status, match_ids, merchant, purchase_date, total_amount, tax_amount, raw_payload, canonical_data, image_url, image_sha256, lat, lon, location_source, location_label, created_at, updated_at
from
  receipts
where
  link_status = 1 -- unlinked
order by
  created_at desc
limit
  COALESCE($1::int, 50)
`

// Utility queries
func (q *Queries) GetUnlinkedReceipts(ctx context.Context, limit *int32) ([]Receipt, error) {
	rows, err := q.db.Query(ctx, getUnlinkedReceipts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Receipt
	for rows.Next() {
		var i Receipt
		if err := rows.Scan(
			&i.ID,
			&i.Engine,
			&i.ParseStatus,
			&i.LinkStatus,
			&i.MatchIds,
			&i.Merchant,
			&i.PurchaseDate,
			&i.TotalAmount,
			&i.TaxAmount,
			&i.RawPayload,
			&i.CanonicalData,
			&i.ImageUrl,
			&i.ImageSha256,
			&i.Lat,
			&i.Lon,
			&i.LocationSource,
			&i.LocationLabel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkTransactionToReceipt = `-- name: LinkTransactionToReceipt :exec
update
  transactions
set
  receipt_id = $1::bigint
where
  id = $2::bigint
  and receipt_id is null
`

type LinkTransactionToReceiptParams struct {
	ReceiptID     int64 `db:"receipt_id" json:"receipt_id"`
	TransactionID int64 `db:"transaction_id" json:"transaction_id"`
}

func (q *Queries) LinkTransactionToReceipt(ctx context.Context, arg LinkTransactionToReceiptParams) error {
	_, err := q.db.Exec(ctx, linkTransactionToReceipt, arg.ReceiptID, arg.TransactionID)
	return err
}

const listReceiptItemsForReceipt = `-- name: ListReceiptItemsForReceipt :many
select
  id,
  receipt_id,
  line_no,
  name,
  qty,
  unit_price,
  line_total,
  sku,
  category_hint,
  created_at,
  updated_at
from
  receipt_items
where
  receipt_id = $1::bigint
order by
  line_no NULLS LAST,
  id
`

// Receipt Items CRUD
func (q *Queries) ListReceiptItemsForReceipt(ctx context.Context, receiptID int64) ([]ReceiptItem, error) {
	rows, err := q.db.Query(ctx, listReceiptItemsForReceipt, receiptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReceiptItem
	for rows.Next() {
		var i ReceiptItem
		if err := rows.Scan(
			&i.ID,
			&i.ReceiptID,
			&i.LineNo,
			&i.Name,
			&i.Qty,
			&i.UnitPrice,
			&i.LineTotal,
			&i.Sku,
			&i.CategoryHint,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReceipts = `-- name: ListReceipts :many
select
  distinct r.id,
  r.engine,
  r.parse_status,
  r.link_status,
  r.match_ids,
  r.merchant,
  r.purchase_date,
  r.total_amount,
  r.tax_amount,
  r.raw_payload,
  r.canonical_data,
  r.image_url,
  r.image_sha256,
  r.lat,
  r.lon,
  r.location_source,
  r.location_label,
  r.created_at,
  r.updated_at
from
  receipts r
  left join transactions t on r.id = t.receipt_id
  left join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  a.owner_id = $1::uuid
  or au.user_id is not null
order by
  r.created_at desc
`

func (q *Queries) ListReceipts(ctx context.Context, userID uuid.UUID) ([]Receipt, error) {
	rows, err := q.db.Query(ctx, listReceipts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Receipt
	for rows.Next() {
		var i Receipt
		if err := rows.Scan(
			&i.ID,
			&i.Engine,
			&i.ParseStatus,
			&i.LinkStatus,
			&i.MatchIds,
			&i.Merchant,
			&i.PurchaseDate,
			&i.TotalAmount,
			&i.TaxAmount,
			&i.RawPayload,
			&i.CanonicalData,
			&i.ImageUrl,
			&i.ImageSha256,
			&i.Lat,
			&i.Lon,
			&i.LocationSource,
			&i.LocationLabel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReceipt = `-- name: UpdateReceipt :execrows
update
  receipts
set
  engine = $1::smallint,
  parse_status = $2::smallint,
  link_status = $3::smallint,
  match_ids = $4::bigint [],
  merchant = $5::text,
  purchase_date = $6::date,
  total_amount = $7::jsonb,
  tax_amount = $8::jsonb,
  raw_payload = $9::jsonb,
  canonical_data = $10::jsonb,
  image_url = $11::text,
  image_sha256 = $12::bytea,
  lat = $13::double precision,
  lon = $14::double precision,
  location_source = $15::text,
  location_label = $16::text
where
  id = $17::bigint
`

type UpdateReceiptParams struct {
	Engine         *int16     `db:"engine" json:"engine"`
	ParseStatus    *int16     `db:"parse_status" json:"parse_status"`
	LinkStatus     *int16     `db:"link_status" json:"link_status"`
	MatchIds       []int64    `db:"match_ids" json:"match_ids"`
	Merchant       *string    `db:"merchant" json:"merchant"`
	PurchaseDate   *time.Time `db:"purchase_date" json:"purchase_date"`
	TotalAmount    []byte     `db:"total_amount" json:"total_amount"`
	TaxAmount      []byte     `db:"tax_amount" json:"tax_amount"`
	RawPayload     []byte     `db:"raw_payload" json:"raw_payload"`
	CanonicalData  []byte     `db:"canonical_data" json:"canonical_data"`
	ImageUrl       *string    `db:"image_url" json:"image_url"`
	ImageSha256    []byte     `db:"image_sha256" json:"image_sha256"`
	Lat            *float64   `db:"lat" json:"lat"`
	Lon            *float64   `db:"lon" json:"lon"`
	LocationSource *string    `db:"location_source" json:"location_source"`
	LocationLabel  *string    `db:"location_label" json:"location_label"`
	ID             int64      `db:"id" json:"id"`
}

func (q *Queries) UpdateReceipt(ctx context.Context, arg UpdateReceiptParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateReceipt,
		arg.Engine,
		arg.ParseStatus,
		arg.LinkStatus,
		arg.MatchIds,
		arg.Merchant,
		arg.PurchaseDate,
		arg.TotalAmount,
		arg.TaxAmount,
		arg.RawPayload,
		arg.CanonicalData,
		arg.ImageUrl,
		arg.ImageSha256,
		arg.Lat,
		arg.Lon,
		arg.LocationSource,
		arg.LocationLabel,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateReceiptItem = `-- name: UpdateReceiptItem :one
update
  receipt_items
set
  line_no = $1::int,
  name = $2::text,
  qty = $3::int,
  unit_price = $4::jsonb,
  line_total = $5::jsonb,
  sku = $6::text,
  category_hint = $7::text
where
  id = $8::bigint
returning
  id,
  receipt_id,
  line_no,
  name,
  qty,
  unit_price,
  line_total,
  sku,
  category_hint,
  created_at,
  updated_at
`

type UpdateReceiptItemParams struct {
	LineNo       *int32  `db:"line_no" json:"line_no"`
	Name         *string `db:"name" json:"name"`
	Qty          *int32  `db:"qty" json:"qty"`
	UnitPrice    []byte  `db:"unit_price" json:"unit_price"`
	LineTotal    []byte  `db:"line_total" json:"line_total"`
	Sku          *string `db:"sku" json:"sku"`
	CategoryHint *string `db:"category_hint" json:"category_hint"`
	ID           int64   `db:"id" json:"id"`
}

func (q *Queries) UpdateReceiptItem(ctx context.Context, arg UpdateReceiptItemParams) (ReceiptItem, error) {
	row := q.db.QueryRow(ctx, updateReceiptItem,
		arg.LineNo,
		arg.Name,
		arg.Qty,
		arg.UnitPrice,
		arg.LineTotal,
		arg.Sku,
		arg.CategoryHint,
		arg.ID,
	)
	var i ReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.LineNo,
		&i.Name,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.Sku,
		&i.CategoryHint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
