// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: receipts.sql

package sqlcdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createReceipt = `-- name: CreateReceipt :one
INSERT INTO receipts (
  engine, parse_status, link_status, match_ids,
  merchant, purchase_date, total_amount, currency, tax_amount,
  raw_payload, canonical_data, image_url, image_sha256,
  lat, lon, location_source, location_label
) VALUES (
  $1::text,
  COALESCE($2::text, 'pending'),
  COALESCE($3::text,  'unlinked'),
  $4::bigint[],
  $5::text,
  $6::date,
  $7::numeric,
  $8::char(3),
  $9::numeric,
  $10::jsonb,
  $11::jsonb,
  $12::text,
  $13::bytea,
  $14::double precision,
  $15::double precision,
  $16::text,
  $17::text
)
RETURNING
  id,
  engine, parse_status, link_status, match_ids,
  merchant, purchase_date, total_amount, currency, tax_amount,
  raw_payload, canonical_data, image_url, image_sha256,
  lat, lon, location_source, location_label,
  created_at, updated_at
`

type CreateReceiptParams struct {
	Engine         string           `json:"engine"`
	ParseStatus    *string          `json:"parseStatus"`
	LinkStatus     *string          `json:"linkStatus"`
	MatchIds       []int64          `json:"matchIds"`
	Merchant       *string          `json:"merchant"`
	PurchaseDate   pgtype.Date      `json:"purchaseDate"`
	TotalAmount    *decimal.Decimal `json:"totalAmount"`
	Currency       *string          `json:"currency"`
	TaxAmount      *decimal.Decimal `json:"taxAmount"`
	RawPayload     []byte           `json:"rawPayload"`
	CanonicalData  []byte           `json:"canonicalData"`
	ImageUrl       *string          `json:"imageUrl"`
	ImageSha256    []byte           `json:"imageSha256"`
	Lat            *float64         `json:"lat"`
	Lon            *float64         `json:"lon"`
	LocationSource *string          `json:"locationSource"`
	LocationLabel  *string          `json:"locationLabel"`
}

func (q *Queries) CreateReceipt(ctx context.Context, arg CreateReceiptParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, createReceipt,
		arg.Engine,
		arg.ParseStatus,
		arg.LinkStatus,
		arg.MatchIds,
		arg.Merchant,
		arg.PurchaseDate,
		arg.TotalAmount,
		arg.Currency,
		arg.TaxAmount,
		arg.RawPayload,
		arg.CanonicalData,
		arg.ImageUrl,
		arg.ImageSha256,
		arg.Lat,
		arg.Lon,
		arg.LocationSource,
		arg.LocationLabel,
	)
	var i Receipt
	err := row.Scan(
		&i.Id,
		&i.Engine,
		&i.ParseStatus,
		&i.LinkStatus,
		&i.MatchIds,
		&i.Merchant,
		&i.PurchaseDate,
		&i.TotalAmount,
		&i.Currency,
		&i.TaxAmount,
		&i.RawPayload,
		&i.CanonicalData,
		&i.ImageUrl,
		&i.ImageSha256,
		&i.Lat,
		&i.Lon,
		&i.LocationSource,
		&i.LocationLabel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReceipt = `-- name: DeleteReceipt :execrows
DELETE FROM receipts WHERE id = $1::bigint
`

func (q *Queries) DeleteReceipt(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReceipt, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getReceipt = `-- name: GetReceipt :one
SELECT
  id,
  engine,             -- text enum: 'gemini' | 'local'
  parse_status,       -- 'pending' | 'success' | 'failed'
  link_status,        -- 'unlinked' | 'matched' | 'needs_verification'
  match_ids,          -- bigint[]
  merchant,
  purchase_date,
  total_amount,
  currency,
  tax_amount,
  raw_payload,
  canonical_data,
  image_url,
  image_sha256,
  lat,
  lon,
  location_source,
  location_label,
  created_at,
  updated_at
FROM receipts
WHERE id = $1::bigint
`

func (q *Queries) GetReceipt(ctx context.Context, id int64) (Receipt, error) {
	row := q.db.QueryRow(ctx, getReceipt, id)
	var i Receipt
	err := row.Scan(
		&i.Id,
		&i.Engine,
		&i.ParseStatus,
		&i.LinkStatus,
		&i.MatchIds,
		&i.Merchant,
		&i.PurchaseDate,
		&i.TotalAmount,
		&i.Currency,
		&i.TaxAmount,
		&i.RawPayload,
		&i.CanonicalData,
		&i.ImageUrl,
		&i.ImageSha256,
		&i.Lat,
		&i.Lon,
		&i.LocationSource,
		&i.LocationLabel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertReceiptItem = `-- name: InsertReceiptItem :exec
INSERT INTO receipt_items (
  receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint
) VALUES (
  $1::bigint,
  $2::int,
  $3::text,
  $4::numeric,
  $5::numeric,
  $6::numeric,
  $7::text,
  $8::text
)
`

type InsertReceiptItemParams struct {
	ReceiptId    int64            `json:"receiptId"`
	LineNo       *int32           `json:"lineNo"`
	Name         string           `json:"name"`
	Qty          *decimal.Decimal `json:"qty"`
	UnitPrice    *decimal.Decimal `json:"unitPrice"`
	LineTotal    *decimal.Decimal `json:"lineTotal"`
	Sku          *string          `json:"sku"`
	CategoryHint *string          `json:"categoryHint"`
}

func (q *Queries) InsertReceiptItem(ctx context.Context, arg InsertReceiptItemParams) error {
	_, err := q.db.Exec(ctx, insertReceiptItem,
		arg.ReceiptId,
		arg.LineNo,
		arg.Name,
		arg.Qty,
		arg.UnitPrice,
		arg.LineTotal,
		arg.Sku,
		arg.CategoryHint,
	)
	return err
}

const listReceiptItemsForReceipt = `-- name: ListReceiptItemsForReceipt :many
SELECT
  id, receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint,
  created_at, updated_at
FROM receipt_items
WHERE receipt_id = $1::bigint
ORDER BY line_no NULLS LAST, id
`

func (q *Queries) ListReceiptItemsForReceipt(ctx context.Context, receiptID int64) ([]ReceiptItem, error) {
	rows, err := q.db.Query(ctx, listReceiptItemsForReceipt, receiptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReceiptItem
	for rows.Next() {
		var i ReceiptItem
		if err := rows.Scan(
			&i.Id,
			&i.ReceiptId,
			&i.LineNo,
			&i.Name,
			&i.Qty,
			&i.UnitPrice,
			&i.LineTotal,
			&i.Sku,
			&i.CategoryHint,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReceipts = `-- name: ListReceipts :many
SELECT
  id,
  engine,
  parse_status,
  link_status,
  match_ids,
  merchant,
  purchase_date,
  total_amount,
  currency,
  tax_amount,
  raw_payload,
  canonical_data,
  image_url,
  image_sha256,
  lat,
  lon,
  location_source,
  location_label,
  created_at,
  updated_at
FROM receipts
ORDER BY created_at DESC
`

func (q *Queries) ListReceipts(ctx context.Context) ([]Receipt, error) {
	rows, err := q.db.Query(ctx, listReceipts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Receipt
	for rows.Next() {
		var i Receipt
		if err := rows.Scan(
			&i.Id,
			&i.Engine,
			&i.ParseStatus,
			&i.LinkStatus,
			&i.MatchIds,
			&i.Merchant,
			&i.PurchaseDate,
			&i.TotalAmount,
			&i.Currency,
			&i.TaxAmount,
			&i.RawPayload,
			&i.CanonicalData,
			&i.ImageUrl,
			&i.ImageSha256,
			&i.Lat,
			&i.Lon,
			&i.LocationSource,
			&i.LocationLabel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReceiptPartial = `-- name: UpdateReceiptPartial :execrows
UPDATE receipts
SET
  engine           = CASE WHEN $1::bool           THEN $2::text                 ELSE engine           END,
  parse_status     = CASE WHEN $3::bool     THEN $4::text          ELSE parse_status     END,
  link_status      = CASE WHEN $5::bool      THEN $6::text           ELSE link_status      END,
  match_ids        = CASE WHEN $7::bool        THEN $8::bigint[] ELSE match_ids   END,
  merchant         = CASE WHEN $9::bool         THEN $10::text  ELSE merchant         END,
  purchase_date    = CASE WHEN $11::bool    THEN $12::date ELSE purchase_date END,
  total_amount     = CASE WHEN $13::bool     THEN $14::numeric ELSE total_amount END,
  currency         = CASE WHEN $15::bool         THEN $16::char(3) ELSE currency       END,
  tax_amount       = CASE WHEN $17::bool       THEN $18::numeric ELSE tax_amount   END,
  raw_payload      = CASE WHEN $19::bool      THEN $20::jsonb ELSE raw_payload   END,
  canonical_data   = CASE WHEN $21::bool   THEN $22::jsonb ELSE canonical_data END,
  image_url        = CASE WHEN $23::bool        THEN $24::text ELSE image_url        END,
  image_sha256     = CASE WHEN $25::bool     THEN $26::bytea ELSE image_sha256 END,
  lat              = CASE WHEN $27::bool              THEN $28::double precision ELSE lat        END,
  lon              = CASE WHEN $29::bool              THEN $30::double precision ELSE lon        END,
  location_source  = CASE WHEN $31::bool  THEN $32::text ELSE location_source END,
  location_label   = CASE WHEN $33::bool   THEN $34::text ELSE location_label END
WHERE id = $35::bigint
`

type UpdateReceiptPartialParams struct {
	EngineSet         bool             `json:"engineSet"`
	Engine            string           `json:"engine"`
	ParseStatusSet    bool             `json:"parseStatusSet"`
	ParseStatus       string           `json:"parseStatus"`
	LinkStatusSet     bool             `json:"linkStatusSet"`
	LinkStatus        string           `json:"linkStatus"`
	MatchIdsSet       bool             `json:"matchIdsSet"`
	MatchIds          []int64          `json:"matchIds"`
	MerchantSet       bool             `json:"merchantSet"`
	Merchant          *string          `json:"merchant"`
	PurchaseDateSet   bool             `json:"purchaseDateSet"`
	PurchaseDate      pgtype.Date      `json:"purchaseDate"`
	TotalAmountSet    bool             `json:"totalAmountSet"`
	TotalAmount       *decimal.Decimal `json:"totalAmount"`
	CurrencySet       bool             `json:"currencySet"`
	Currency          *string          `json:"currency"`
	TaxAmountSet      bool             `json:"taxAmountSet"`
	TaxAmount         *decimal.Decimal `json:"taxAmount"`
	RawPayloadSet     bool             `json:"rawPayloadSet"`
	RawPayload        []byte           `json:"rawPayload"`
	CanonicalDataSet  bool             `json:"canonicalDataSet"`
	CanonicalData     []byte           `json:"canonicalData"`
	ImageUrlSet       bool             `json:"imageUrlSet"`
	ImageUrl          *string          `json:"imageUrl"`
	ImageSha256Set    bool             `json:"imageSha256Set"`
	ImageSha256       []byte           `json:"imageSha256"`
	LatSet            bool             `json:"latSet"`
	Lat               *float64         `json:"lat"`
	LonSet            bool             `json:"lonSet"`
	Lon               *float64         `json:"lon"`
	LocationSourceSet bool             `json:"locationSourceSet"`
	LocationSource    *string          `json:"locationSource"`
	LocationLabelSet  bool             `json:"locationLabelSet"`
	LocationLabel     *string          `json:"locationLabel"`
	Id                int64            `json:"id"`
}

func (q *Queries) UpdateReceiptPartial(ctx context.Context, arg UpdateReceiptPartialParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateReceiptPartial,
		arg.EngineSet,
		arg.Engine,
		arg.ParseStatusSet,
		arg.ParseStatus,
		arg.LinkStatusSet,
		arg.LinkStatus,
		arg.MatchIdsSet,
		arg.MatchIds,
		arg.MerchantSet,
		arg.Merchant,
		arg.PurchaseDateSet,
		arg.PurchaseDate,
		arg.TotalAmountSet,
		arg.TotalAmount,
		arg.CurrencySet,
		arg.Currency,
		arg.TaxAmountSet,
		arg.TaxAmount,
		arg.RawPayloadSet,
		arg.RawPayload,
		arg.CanonicalDataSet,
		arg.CanonicalData,
		arg.ImageUrlSet,
		arg.ImageUrl,
		arg.ImageSha256Set,
		arg.ImageSha256,
		arg.LatSet,
		arg.Lat,
		arg.LonSet,
		arg.Lon,
		arg.LocationSourceSet,
		arg.LocationSource,
		arg.LocationLabelSet,
		arg.LocationLabel,
		arg.Id,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
