// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: receipts.sql

package sqlc

import (
	"context"
	"time"

	"ariand/internal/types"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

type BulkCreateReceiptItemsParams struct {
	ReceiptID    int64               `json:"receipt_id"`
	LineNo       *int32              `json:"line_no"`
	Name         string              `json:"name"`
	Qty          *decimal.Decimal    `json:"qty"`
	UnitPrice    *types.MoneyWrapper `json:"unit_price"`
	LineTotal    *types.MoneyWrapper `json:"line_total"`
	Sku          *string             `json:"sku"`
	CategoryHint *string             `json:"category_hint"`
}

const createReceipt = `-- name: CreateReceipt :one
INSERT INTO receipts (
  engine, parse_status, link_status, match_ids,
  merchant, purchase_date, total_amount, tax_amount,
  raw_payload, canonical_data, image_url, image_sha256,
  lat, lon, location_source, location_label
) VALUES (
  $1::smallint,
  COALESCE($2::smallint, 1),
  COALESCE($3::smallint, 1),
  $4::bigint[],
  $5::text,
  $6::date,
  $7::jsonb,
  $8::jsonb,
  $9::jsonb,
  $10::jsonb,
  $11::text,
  $12::bytea,
  $13::double precision,
  $14::double precision,
  $15::text,
  $16::text
)
RETURNING
  id, engine, parse_status, link_status, match_ids,
  merchant, purchase_date, total_amount, tax_amount,
  raw_payload, canonical_data, image_url, image_sha256,
  lat, lon, location_source, location_label,
  created_at, updated_at
`

type CreateReceiptParams struct {
	Engine         int16      `json:"engine"`
	ParseStatus    *int16     `json:"parse_status"`
	LinkStatus     *int16     `json:"link_status"`
	MatchIds       []int64    `json:"match_ids"`
	Merchant       *string    `json:"merchant"`
	PurchaseDate   *time.Time `json:"purchase_date"`
	TotalAmount    []byte     `json:"total_amount"`
	TaxAmount      []byte     `json:"tax_amount"`
	RawPayload     []byte     `json:"raw_payload"`
	CanonicalData  []byte     `json:"canonical_data"`
	ImageUrl       *string    `json:"image_url"`
	ImageSha256    []byte     `json:"image_sha256"`
	Lat            *float64   `json:"lat"`
	Lon            *float64   `json:"lon"`
	LocationSource *string    `json:"location_source"`
	LocationLabel  *string    `json:"location_label"`
}

func (q *Queries) CreateReceipt(ctx context.Context, arg CreateReceiptParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, createReceipt,
		arg.Engine,
		arg.ParseStatus,
		arg.LinkStatus,
		arg.MatchIds,
		arg.Merchant,
		arg.PurchaseDate,
		arg.TotalAmount,
		arg.TaxAmount,
		arg.RawPayload,
		arg.CanonicalData,
		arg.ImageUrl,
		arg.ImageSha256,
		arg.Lat,
		arg.Lon,
		arg.LocationSource,
		arg.LocationLabel,
	)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.Engine,
		&i.ParseStatus,
		&i.LinkStatus,
		&i.MatchIds,
		&i.Merchant,
		&i.PurchaseDate,
		&i.TotalAmount,
		&i.TaxAmount,
		&i.RawPayload,
		&i.CanonicalData,
		&i.ImageUrl,
		&i.ImageSha256,
		&i.Lat,
		&i.Lon,
		&i.LocationSource,
		&i.LocationLabel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createReceiptItem = `-- name: CreateReceiptItem :one
INSERT INTO receipt_items (
  receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint
) VALUES (
  $1::bigint,
  $2::int,
  $3::text,
  COALESCE($4::numeric, 1),
  $5::jsonb,
  $6::jsonb,
  $7::text,
  $8::text
)
RETURNING id, receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint,
          created_at, updated_at
`

type CreateReceiptItemParams struct {
	ReceiptID    int64            `json:"receipt_id"`
	LineNo       *int32           `json:"line_no"`
	Name         string           `json:"name"`
	Qty          *decimal.Decimal `json:"qty"`
	UnitPrice    []byte           `json:"unit_price"`
	LineTotal    []byte           `json:"line_total"`
	Sku          *string          `json:"sku"`
	CategoryHint *string          `json:"category_hint"`
}

func (q *Queries) CreateReceiptItem(ctx context.Context, arg CreateReceiptItemParams) (ReceiptItem, error) {
	row := q.db.QueryRow(ctx, createReceiptItem,
		arg.ReceiptID,
		arg.LineNo,
		arg.Name,
		arg.Qty,
		arg.UnitPrice,
		arg.LineTotal,
		arg.Sku,
		arg.CategoryHint,
	)
	var i ReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.LineNo,
		&i.Name,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.Sku,
		&i.CategoryHint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReceipt = `-- name: DeleteReceipt :execrows
DELETE FROM receipts 
WHERE id = $1::bigint
  AND EXISTS (
    SELECT 1 FROM transactions t
    JOIN accounts a ON t.account_id = a.id
    LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $2::uuid
    WHERE t.receipt_id = receipts.id
      AND (a.owner_id = $2::uuid OR au.user_id IS NOT NULL)
  )
`

type DeleteReceiptParams struct {
	ID     int64     `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteReceipt(ctx context.Context, arg DeleteReceiptParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReceipt, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteReceiptItem = `-- name: DeleteReceiptItem :execrows
DELETE FROM receipt_items WHERE id = $1::bigint
`

func (q *Queries) DeleteReceiptItem(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReceiptItem, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteReceiptItemsByReceipt = `-- name: DeleteReceiptItemsByReceipt :execrows
DELETE FROM receipt_items WHERE receipt_id = $1::bigint
`

func (q *Queries) DeleteReceiptItemsByReceipt(ctx context.Context, receiptID int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReceiptItemsByReceipt, receiptID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getReceipt = `-- name: GetReceipt :one
SELECT DISTINCT
  r.id, r.engine, r.parse_status, r.link_status, r.match_ids,
  r.merchant, r.purchase_date, r.total_amount, r.tax_amount,
  r.raw_payload, r.canonical_data, r.image_url, r.image_sha256,
  r.lat, r.lon, r.location_source, r.location_label,
  r.created_at, r.updated_at
FROM receipts r
LEFT JOIN transactions t ON r.id = t.receipt_id
LEFT JOIN accounts a ON t.account_id = a.id
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
WHERE r.id = $2::bigint
  AND (a.owner_id = $1::uuid OR au.user_id IS NOT NULL)
`

type GetReceiptParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     int64     `json:"id"`
}

func (q *Queries) GetReceipt(ctx context.Context, arg GetReceiptParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, getReceipt, arg.UserID, arg.ID)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.Engine,
		&i.ParseStatus,
		&i.LinkStatus,
		&i.MatchIds,
		&i.Merchant,
		&i.PurchaseDate,
		&i.TotalAmount,
		&i.TaxAmount,
		&i.RawPayload,
		&i.CanonicalData,
		&i.ImageUrl,
		&i.ImageSha256,
		&i.Lat,
		&i.Lon,
		&i.LocationSource,
		&i.LocationLabel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReceiptItem = `-- name: GetReceiptItem :one
SELECT
  id, receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint,
  created_at, updated_at
FROM receipt_items
WHERE id = $1::bigint
`

func (q *Queries) GetReceiptItem(ctx context.Context, id int64) (ReceiptItem, error) {
	row := q.db.QueryRow(ctx, getReceiptItem, id)
	var i ReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.LineNo,
		&i.Name,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.Sku,
		&i.CategoryHint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReceiptMatchCandidates = `-- name: GetReceiptMatchCandidates :many
SELECT r.id, r.merchant, r.purchase_date, r.total_amount,
       COUNT(t.id) AS potential_matches
FROM receipts r
LEFT JOIN transactions t ON t.id = ANY(r.match_ids)
WHERE r.link_status = 3  -- needs verification
GROUP BY r.id, r.merchant, r.purchase_date, r.total_amount
ORDER BY r.created_at DESC
`

type GetReceiptMatchCandidatesRow struct {
	ID               int64               `json:"id"`
	Merchant         *string             `json:"merchant"`
	PurchaseDate     *time.Time          `json:"purchase_date"`
	TotalAmount      *types.MoneyWrapper `json:"total_amount"`
	PotentialMatches int64               `json:"potential_matches"`
}

func (q *Queries) GetReceiptMatchCandidates(ctx context.Context) ([]GetReceiptMatchCandidatesRow, error) {
	rows, err := q.db.Query(ctx, getReceiptMatchCandidates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReceiptMatchCandidatesRow
	for rows.Next() {
		var i GetReceiptMatchCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Merchant,
			&i.PurchaseDate,
			&i.TotalAmount,
			&i.PotentialMatches,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnlinkedReceipts = `-- name: GetUnlinkedReceipts :many
SELECT id, merchant, purchase_date, total_amount, created_at
FROM receipts
WHERE link_status = 1  -- unlinked
ORDER BY created_at DESC
LIMIT COALESCE($1::int, 50)
`

type GetUnlinkedReceiptsRow struct {
	ID           int64               `json:"id"`
	Merchant     *string             `json:"merchant"`
	PurchaseDate *time.Time          `json:"purchase_date"`
	TotalAmount  *types.MoneyWrapper `json:"total_amount"`
	CreatedAt    time.Time           `json:"created_at"`
}

// Utility queries
func (q *Queries) GetUnlinkedReceipts(ctx context.Context, limit *int32) ([]GetUnlinkedReceiptsRow, error) {
	rows, err := q.db.Query(ctx, getUnlinkedReceipts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnlinkedReceiptsRow
	for rows.Next() {
		var i GetUnlinkedReceiptsRow
		if err := rows.Scan(
			&i.ID,
			&i.Merchant,
			&i.PurchaseDate,
			&i.TotalAmount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkTransactionToReceipt = `-- name: LinkTransactionToReceipt :exec
UPDATE transactions 
SET receipt_id = $1::bigint
WHERE id = $2::bigint
  AND receipt_id IS NULL
`

type LinkTransactionToReceiptParams struct {
	ReceiptID     int64 `json:"receipt_id"`
	TransactionID int64 `json:"transaction_id"`
}

func (q *Queries) LinkTransactionToReceipt(ctx context.Context, arg LinkTransactionToReceiptParams) error {
	_, err := q.db.Exec(ctx, linkTransactionToReceipt, arg.ReceiptID, arg.TransactionID)
	return err
}

const listReceiptItemsForReceipt = `-- name: ListReceiptItemsForReceipt :many
SELECT
  id, receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint,
  created_at, updated_at
FROM receipt_items
WHERE receipt_id = $1::bigint
ORDER BY line_no NULLS LAST, id
`

// Receipt Items CRUD
func (q *Queries) ListReceiptItemsForReceipt(ctx context.Context, receiptID int64) ([]ReceiptItem, error) {
	rows, err := q.db.Query(ctx, listReceiptItemsForReceipt, receiptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReceiptItem
	for rows.Next() {
		var i ReceiptItem
		if err := rows.Scan(
			&i.ID,
			&i.ReceiptID,
			&i.LineNo,
			&i.Name,
			&i.Qty,
			&i.UnitPrice,
			&i.LineTotal,
			&i.Sku,
			&i.CategoryHint,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReceipts = `-- name: ListReceipts :many
SELECT DISTINCT
  r.id, r.engine, r.parse_status, r.link_status, r.match_ids,
  r.merchant, r.purchase_date, r.total_amount, r.tax_amount,
  r.raw_payload, r.canonical_data, r.image_url, r.image_sha256,
  r.lat, r.lon, r.location_source, r.location_label,
  r.created_at, r.updated_at
FROM receipts r
LEFT JOIN transactions t ON r.id = t.receipt_id
LEFT JOIN accounts a ON t.account_id = a.id
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
WHERE a.owner_id = $1::uuid OR au.user_id IS NOT NULL
ORDER BY r.created_at DESC
`

func (q *Queries) ListReceipts(ctx context.Context, userID uuid.UUID) ([]Receipt, error) {
	rows, err := q.db.Query(ctx, listReceipts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Receipt
	for rows.Next() {
		var i Receipt
		if err := rows.Scan(
			&i.ID,
			&i.Engine,
			&i.ParseStatus,
			&i.LinkStatus,
			&i.MatchIds,
			&i.Merchant,
			&i.PurchaseDate,
			&i.TotalAmount,
			&i.TaxAmount,
			&i.RawPayload,
			&i.CanonicalData,
			&i.ImageUrl,
			&i.ImageSha256,
			&i.Lat,
			&i.Lon,
			&i.LocationSource,
			&i.LocationLabel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReceipt = `-- name: UpdateReceipt :execrows
UPDATE receipts
SET engine = COALESCE($1::smallint, engine),
    parse_status = COALESCE($2::smallint, parse_status),
    link_status = COALESCE($3::smallint, link_status),
    match_ids = COALESCE($4::bigint[], match_ids),
    merchant = COALESCE($5::text, merchant),
    purchase_date = COALESCE($6::date, purchase_date),
    total_amount = COALESCE($7::jsonb, total_amount),
    tax_amount = COALESCE($8::jsonb, tax_amount),
    raw_payload = COALESCE($9::jsonb, raw_payload),
    canonical_data = COALESCE($10::jsonb, canonical_data),
    image_url = COALESCE($11::text, image_url),
    image_sha256 = COALESCE($12::bytea, image_sha256),
    lat = COALESCE($13::double precision, lat),
    lon = COALESCE($14::double precision, lon),
    location_source = COALESCE($15::text, location_source),
    location_label = COALESCE($16::text, location_label)
WHERE id = $17::bigint
`

type UpdateReceiptParams struct {
	Engine         *int16     `json:"engine"`
	ParseStatus    *int16     `json:"parse_status"`
	LinkStatus     *int16     `json:"link_status"`
	MatchIds       []int64    `json:"match_ids"`
	Merchant       *string    `json:"merchant"`
	PurchaseDate   *time.Time `json:"purchase_date"`
	TotalAmount    []byte     `json:"total_amount"`
	TaxAmount      []byte     `json:"tax_amount"`
	RawPayload     []byte     `json:"raw_payload"`
	CanonicalData  []byte     `json:"canonical_data"`
	ImageUrl       *string    `json:"image_url"`
	ImageSha256    []byte     `json:"image_sha256"`
	Lat            *float64   `json:"lat"`
	Lon            *float64   `json:"lon"`
	LocationSource *string    `json:"location_source"`
	LocationLabel  *string    `json:"location_label"`
	ID             int64      `json:"id"`
}

func (q *Queries) UpdateReceipt(ctx context.Context, arg UpdateReceiptParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateReceipt,
		arg.Engine,
		arg.ParseStatus,
		arg.LinkStatus,
		arg.MatchIds,
		arg.Merchant,
		arg.PurchaseDate,
		arg.TotalAmount,
		arg.TaxAmount,
		arg.RawPayload,
		arg.CanonicalData,
		arg.ImageUrl,
		arg.ImageSha256,
		arg.Lat,
		arg.Lon,
		arg.LocationSource,
		arg.LocationLabel,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateReceiptItem = `-- name: UpdateReceiptItem :one
UPDATE receipt_items
SET line_no = COALESCE($1::int, line_no),
    name = COALESCE($2::text, name),
    qty = COALESCE($3::numeric, qty),
    unit_price = COALESCE($4::jsonb, unit_price),
    line_total = COALESCE($5::jsonb, line_total),
    sku = COALESCE($6::text, sku),
    category_hint = COALESCE($7::text, category_hint)
WHERE id = $8::bigint
RETURNING id, receipt_id, line_no, name, qty, unit_price, line_total, sku, category_hint,
          created_at, updated_at
`

type UpdateReceiptItemParams struct {
	LineNo       *int32           `json:"line_no"`
	Name         *string          `json:"name"`
	Qty          *decimal.Decimal `json:"qty"`
	UnitPrice    []byte           `json:"unit_price"`
	LineTotal    []byte           `json:"line_total"`
	Sku          *string          `json:"sku"`
	CategoryHint *string          `json:"category_hint"`
	ID           int64            `json:"id"`
}

func (q *Queries) UpdateReceiptItem(ctx context.Context, arg UpdateReceiptItemParams) (ReceiptItem, error) {
	row := q.db.QueryRow(ctx, updateReceiptItem,
		arg.LineNo,
		arg.Name,
		arg.Qty,
		arg.UnitPrice,
		arg.LineTotal,
		arg.Sku,
		arg.CategoryHint,
		arg.ID,
	)
	var i ReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.LineNo,
		&i.Name,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.Sku,
		&i.CategoryHint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
