// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dashboard.sql

package sqlc

import (
	"context"
	"time"

	arian "ariand/internal/gen/arian/v1"
	"github.com/google/uuid"
)

const getAccountBalances = `-- name: GetAccountBalances :many
select
  a.id,
  a.name,
  a.account_type,
  jsonb_build_object(
    'currency_code',
    a.anchor_balance ->> 'currency_code',
    'units',
    (
      (a.anchor_balance ->> 'units')::bigint + COALESCE(d.delta, 0)
    )::bigint,
    'nanos',
    0
  ) as current_balance
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
  left join LATERAL (
    select
      SUM(
        case
          when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
          when t.tx_direction = 2 then -(
            (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
          )
        end
      ) as delta
    from
      transactions t
    where
      t.account_id = a.id
      and t.tx_date > a.anchor_date
  ) d on true
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
order by
  current_balance desc
`

type GetAccountBalancesRow struct {
	ID             int64             `json:"id"`
	Name           string            `json:"name"`
	AccountType    arian.AccountType `json:"account_type"`
	CurrentBalance []byte            `json:"current_balance"`
}

func (q *Queries) GetAccountBalances(ctx context.Context, userID uuid.UUID) ([]GetAccountBalancesRow, error) {
	rows, err := q.db.Query(ctx, getAccountBalances, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountBalancesRow
	for rows.Next() {
		var i GetAccountBalancesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AccountType,
			&i.CurrentBalance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardSummary = `-- name: GetDashboardSummary :one
select
  COUNT(distinct a.id) as total_accounts,
  COUNT(t.id) as total_transactions,
  COALESCE(
    SUM(
      case
        when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
        else 0
      end
    ),
    0
  ) as total_income,
  COALESCE(
    SUM(
      case
        when t.tx_direction = 2 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
        else 0
      end
    ),
    0
  ) as total_expenses,
  COUNT(
    distinct case
      when t.tx_date >= CURRENT_DATE - interval '30 days' then t.id
    end
  ) as transactions_last_30_days,
  COUNT(
    distinct case
      when t.category_id is null then t.id
    end
  ) as uncategorized_transactions
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
  left join transactions t on a.id = t.account_id
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
  and (
    $2::timestamptz is null
    or t.tx_date >= $2::timestamptz
  )
  and (
    $3::timestamptz is null
    or t.tx_date <= $3::timestamptz
  )
`

type GetDashboardSummaryParams struct {
	UserID uuid.UUID  `json:"user_id"`
	Start  *time.Time `json:"start"`
	End    *time.Time `json:"end"`
}

type GetDashboardSummaryRow struct {
	TotalAccounts             int64       `json:"total_accounts"`
	TotalTransactions         int64       `json:"total_transactions"`
	TotalIncome               interface{} `json:"total_income"`
	TotalExpenses             interface{} `json:"total_expenses"`
	TransactionsLast30Days    int64       `json:"transactions_last_30_days"`
	UncategorizedTransactions int64       `json:"uncategorized_transactions"`
}

func (q *Queries) GetDashboardSummary(ctx context.Context, arg GetDashboardSummaryParams) (GetDashboardSummaryRow, error) {
	row := q.db.QueryRow(ctx, getDashboardSummary, arg.UserID, arg.Start, arg.End)
	var i GetDashboardSummaryRow
	err := row.Scan(
		&i.TotalAccounts,
		&i.TotalTransactions,
		&i.TotalIncome,
		&i.TotalExpenses,
		&i.TransactionsLast30Days,
		&i.UncategorizedTransactions,
	)
	return i, err
}

const getDashboardSummaryForAccount = `-- name: GetDashboardSummaryForAccount :one
select
  COUNT(distinct a.id) as total_accounts,
  COUNT(t.id) as total_transactions,
  COALESCE(
    SUM(
      case
        when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
        else 0
      end
    ),
    0
  ) as total_income,
  COALESCE(
    SUM(
      case
        when t.tx_direction = 2 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
        else 0
      end
    ),
    0
  ) as total_expenses,
  COUNT(
    distinct case
      when t.tx_date >= CURRENT_DATE - interval '30 days' then t.id
    end
  ) as transactions_last_30_days,
  COUNT(
    distinct case
      when t.category_id is null then t.id
    end
  ) as uncategorized_transactions
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
  left join transactions t on a.id = t.account_id
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
  and a.id = $2::bigint
  and (
    $3::timestamptz is null
    or t.tx_date >= $3::timestamptz
  )
  and (
    $4::timestamptz is null
    or t.tx_date <= $4::timestamptz
  )
`

type GetDashboardSummaryForAccountParams struct {
	UserID    uuid.UUID  `json:"user_id"`
	AccountID int64      `json:"account_id"`
	Start     *time.Time `json:"start"`
	End       *time.Time `json:"end"`
}

type GetDashboardSummaryForAccountRow struct {
	TotalAccounts             int64       `json:"total_accounts"`
	TotalTransactions         int64       `json:"total_transactions"`
	TotalIncome               interface{} `json:"total_income"`
	TotalExpenses             interface{} `json:"total_expenses"`
	TransactionsLast30Days    int64       `json:"transactions_last_30_days"`
	UncategorizedTransactions int64       `json:"uncategorized_transactions"`
}

func (q *Queries) GetDashboardSummaryForAccount(ctx context.Context, arg GetDashboardSummaryForAccountParams) (GetDashboardSummaryForAccountRow, error) {
	row := q.db.QueryRow(ctx, getDashboardSummaryForAccount,
		arg.UserID,
		arg.AccountID,
		arg.Start,
		arg.End,
	)
	var i GetDashboardSummaryForAccountRow
	err := row.Scan(
		&i.TotalAccounts,
		&i.TotalTransactions,
		&i.TotalIncome,
		&i.TotalExpenses,
		&i.TransactionsLast30Days,
		&i.UncategorizedTransactions,
	)
	return i, err
}

const getDashboardTrends = `-- name: GetDashboardTrends :many
select
  to_char(t.tx_date::date, 'YYYY-MM-DD') as date,
  SUM(
    case
      when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
      else 0
    end
  ) as income,
  SUM(
    case
      when t.tx_direction = 2 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
      else 0
    end
  ) as expenses
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
  and (
    $2::timestamptz is null
    or t.tx_date >= $2::timestamptz
  )
  and (
    $3::timestamptz is null
    or t.tx_date <= $3::timestamptz
  )
group by
  date
order by
  date
`

type GetDashboardTrendsParams struct {
	UserID uuid.UUID  `json:"user_id"`
	Start  *time.Time `json:"start"`
	End    *time.Time `json:"end"`
}

type GetDashboardTrendsRow struct {
	Date     string `json:"date"`
	Income   int64  `json:"income"`
	Expenses int64  `json:"expenses"`
}

func (q *Queries) GetDashboardTrends(ctx context.Context, arg GetDashboardTrendsParams) ([]GetDashboardTrendsRow, error) {
	rows, err := q.db.Query(ctx, getDashboardTrends, arg.UserID, arg.Start, arg.End)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDashboardTrendsRow
	for rows.Next() {
		var i GetDashboardTrendsRow
		if err := rows.Scan(&i.Date, &i.Income, &i.Expenses); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardTrendsForAccount = `-- name: GetDashboardTrendsForAccount :many
select
  to_char(t.tx_date::date, 'YYYY-MM-DD') as date,
  SUM(
    case
      when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
      else 0
    end
  ) as income,
  SUM(
    case
      when t.tx_direction = 2 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
      else 0
    end
  ) as expenses
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
  and a.id = $2::bigint
  and (
    $3::timestamptz is null
    or t.tx_date >= $3::timestamptz
  )
  and (
    $4::timestamptz is null
    or t.tx_date <= $4::timestamptz
  )
group by
  date
order by
  date
`

type GetDashboardTrendsForAccountParams struct {
	UserID    uuid.UUID  `json:"user_id"`
	AccountID int64      `json:"account_id"`
	Start     *time.Time `json:"start"`
	End       *time.Time `json:"end"`
}

type GetDashboardTrendsForAccountRow struct {
	Date     string `json:"date"`
	Income   int64  `json:"income"`
	Expenses int64  `json:"expenses"`
}

func (q *Queries) GetDashboardTrendsForAccount(ctx context.Context, arg GetDashboardTrendsForAccountParams) ([]GetDashboardTrendsForAccountRow, error) {
	rows, err := q.db.Query(ctx, getDashboardTrendsForAccount,
		arg.UserID,
		arg.AccountID,
		arg.Start,
		arg.End,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDashboardTrendsForAccountRow
	for rows.Next() {
		var i GetDashboardTrendsForAccountRow
		if err := rows.Scan(&i.Date, &i.Income, &i.Expenses); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyComparison = `-- name: GetMonthlyComparison :many
select
  to_char(t.tx_date, 'YYYY-MM') as month,
  SUM(
    case
      when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
      else 0
    end
  ) as income,
  SUM(
    case
      when t.tx_direction = 2 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
      else 0
    end
  ) as expenses,
  SUM(
    case
      when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
      else -(
        (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
      )
    end
  ) as net
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
  and t.tx_date >= COALESCE(
    $2::timestamptz,
    CURRENT_DATE - interval '12 months'
  )
  and t.tx_date <= COALESCE($3::timestamptz, CURRENT_DATE)
group by
  month
order by
  month
`

type GetMonthlyComparisonParams struct {
	UserID uuid.UUID  `json:"user_id"`
	Start  *time.Time `json:"start"`
	End    *time.Time `json:"end"`
}

type GetMonthlyComparisonRow struct {
	Month    string `json:"month"`
	Income   int64  `json:"income"`
	Expenses int64  `json:"expenses"`
	Net      int64  `json:"net"`
}

func (q *Queries) GetMonthlyComparison(ctx context.Context, arg GetMonthlyComparisonParams) ([]GetMonthlyComparisonRow, error) {
	rows, err := q.db.Query(ctx, getMonthlyComparison, arg.UserID, arg.Start, arg.End)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonthlyComparisonRow
	for rows.Next() {
		var i GetMonthlyComparisonRow
		if err := rows.Scan(
			&i.Month,
			&i.Income,
			&i.Expenses,
			&i.Net,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCategories = `-- name: GetTopCategories :many
select
  c.slug,
  c.color,
  COUNT(t.id) as transaction_count,
  SUM(
    (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
  ) as total_amount
from
  transactions t
  join categories c on t.category_id = c.id
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
  and t.tx_direction = 2 -- expenses only
  and (
    $2::timestamptz is null
    or t.tx_date >= $2::timestamptz
  )
  and (
    $3::timestamptz is null
    or t.tx_date <= $3::timestamptz
  )
group by
  c.id,
  c.slug,
  c.color
order by
  total_amount desc
limit
  COALESCE($4::int, 10)
`

type GetTopCategoriesParams struct {
	UserID uuid.UUID  `json:"user_id"`
	Start  *time.Time `json:"start"`
	End    *time.Time `json:"end"`
	Limit  *int32     `json:"limit"`
}

type GetTopCategoriesRow struct {
	Slug             string `json:"slug"`
	Color            string `json:"color"`
	TransactionCount int64  `json:"transaction_count"`
	TotalAmount      int64  `json:"total_amount"`
}

func (q *Queries) GetTopCategories(ctx context.Context, arg GetTopCategoriesParams) ([]GetTopCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getTopCategories,
		arg.UserID,
		arg.Start,
		arg.End,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopCategoriesRow
	for rows.Next() {
		var i GetTopCategoriesRow
		if err := rows.Scan(
			&i.Slug,
			&i.Color,
			&i.TransactionCount,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopMerchants = `-- name: GetTopMerchants :many
select
  t.merchant,
  COUNT(t.id) as transaction_count,
  SUM(
    (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
  ) as total_amount,
  AVG(
    (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
  ) as avg_amount
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
  and t.merchant is not null
  and t.tx_direction = 2 -- expenses only
  and (
    $2::timestamptz is null
    or t.tx_date >= $2::timestamptz
  )
  and (
    $3::timestamptz is null
    or t.tx_date <= $3::timestamptz
  )
group by
  t.merchant
order by
  total_amount desc
limit
  COALESCE($4::int, 10)
`

type GetTopMerchantsParams struct {
	UserID uuid.UUID  `json:"user_id"`
	Start  *time.Time `json:"start"`
	End    *time.Time `json:"end"`
	Limit  *int32     `json:"limit"`
}

type GetTopMerchantsRow struct {
	Merchant         *string `json:"merchant"`
	TransactionCount int64   `json:"transaction_count"`
	TotalAmount      int64   `json:"total_amount"`
	AvgAmount        float64 `json:"avg_amount"`
}

func (q *Queries) GetTopMerchants(ctx context.Context, arg GetTopMerchantsParams) ([]GetTopMerchantsRow, error) {
	rows, err := q.db.Query(ctx, getTopMerchants,
		arg.UserID,
		arg.Start,
		arg.End,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopMerchantsRow
	for rows.Next() {
		var i GetTopMerchantsRow
		if err := rows.Scan(
			&i.Merchant,
			&i.TransactionCount,
			&i.TotalAmount,
			&i.AvgAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
