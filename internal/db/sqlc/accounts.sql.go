// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package sqlc

import (
	"context"
	"time"

	arian "ariand/internal/gen/arian/v1"
	"ariand/internal/types"
	"github.com/google/uuid"
)

const checkUserAccountAccess = `-- name: CheckUserAccountAccess :one
select
  exists(
    select
      1
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $1::uuid
    where
      a.id = $2::bigint
      and (
        a.owner_id = $1::uuid
        or au.user_id is not null
      )
  ) as has_access
`

type CheckUserAccountAccessParams struct {
	UserID    uuid.UUID `json:"user_id"`
	AccountID int64     `json:"account_id"`
}

func (q *Queries) CheckUserAccountAccess(ctx context.Context, arg CheckUserAccountAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserAccountAccess, arg.UserID, arg.AccountID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const createAccount = `-- name: CreateAccount :one
insert into
  accounts (
    owner_id,
    name,
    bank,
    account_type,
    alias,
    anchor_balance,
    balance,
    main_currency,
    colors
  )
values
  (
    $1::uuid,
    $2::text,
    $3::text,
    $4::smallint,
    $5::text,
    $6::jsonb,
    $6::jsonb,
    $7::text,
    $8::text []
  )
returning
  id, owner_id, name, bank, account_type, alias, anchor_date, anchor_balance, created_at, updated_at, main_currency, colors, balance
`

type CreateAccountParams struct {
	OwnerID       uuid.UUID `json:"owner_id"`
	Name          string    `json:"name"`
	Bank          string    `json:"bank"`
	AccountType   int16     `json:"account_type"`
	Alias         *string   `json:"alias"`
	AnchorBalance []byte    `json:"anchor_balance"`
	MainCurrency  string    `json:"main_currency"`
	Colors        []string  `json:"colors"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.OwnerID,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorBalance,
		arg.MainCurrency,
		arg.Colors,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainCurrency,
		&i.Colors,
		&i.Balance,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :execrows
delete from
  accounts
where
  id = $1::bigint
  and owner_id = $2::uuid
`

type DeleteAccountParams struct {
	ID     int64     `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteAccount(ctx context.Context, arg DeleteAccountParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAccount, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAccount = `-- name: GetAccount :one
select
  a.id,
  a.owner_id,
  a.name,
  a.bank,
  a.account_type,
  a.alias,
  a.anchor_date,
  a.anchor_balance,
  a.balance,
  a.main_currency,
  a.colors,
  a.created_at,
  a.updated_at,
  (a.owner_id = $1::uuid) as is_owner
from
  accounts a
  left join account_users au on au.account_id = a.id
  and au.user_id = $1::uuid
where
  a.id = $2::bigint
  and (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
`

type GetAccountParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     int64     `json:"id"`
}

type GetAccountRow struct {
	ID            int64             `json:"id"`
	OwnerID       uuid.UUID         `json:"owner_id"`
	Name          string            `json:"name"`
	Bank          string            `json:"bank"`
	AccountType   arian.AccountType `json:"account_type"`
	Alias         *string           `json:"alias"`
	AnchorDate    time.Time         `json:"anchor_date"`
	AnchorBalance *types.Money      `json:"anchor_balance"`
	Balance       []byte            `json:"balance"`
	MainCurrency  string            `json:"main_currency"`
	Colors        []string          `json:"colors"`
	CreatedAt     time.Time         `json:"created_at"`
	UpdatedAt     time.Time         `json:"updated_at"`
	IsOwner       bool              `json:"is_owner"`
}

func (q *Queries) GetAccount(ctx context.Context, arg GetAccountParams) (GetAccountRow, error) {
	row := q.db.QueryRow(ctx, getAccount, arg.UserID, arg.ID)
	var i GetAccountRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.Balance,
		&i.MainCurrency,
		&i.Colors,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsOwner,
	)
	return i, err
}

const getAccountAnchorBalance = `-- name: GetAccountAnchorBalance :one
select
  anchor_balance
from
  accounts
where
  id = $1::bigint
`

func (q *Queries) GetAccountAnchorBalance(ctx context.Context, id int64) (*types.Money, error) {
	row := q.db.QueryRow(ctx, getAccountAnchorBalance, id)
	var anchor_balance *types.Money
	err := row.Scan(&anchor_balance)
	return anchor_balance, err
}

const getAccountBalance = `-- name: GetAccountBalance :one
select
  balance_after
from
  transactions
where
  account_id = $1::bigint
order by
  tx_date desc,
  id desc
limit
  1
`

func (q *Queries) GetAccountBalance(ctx context.Context, accountID int64) (*types.Money, error) {
	row := q.db.QueryRow(ctx, getAccountBalance, accountID)
	var balance_after *types.Money
	err := row.Scan(&balance_after)
	return balance_after, err
}

const getAccountBalanceSimple = `-- name: GetAccountBalanceSimple :one
select
  balance
from
  accounts
where
  id = $1::bigint
`

func (q *Queries) GetAccountBalanceSimple(ctx context.Context, accountID int64) ([]byte, error) {
	row := q.db.QueryRow(ctx, getAccountBalanceSimple, accountID)
	var balance []byte
	err := row.Scan(&balance)
	return balance, err
}

const getUserAccountsCount = `-- name: GetUserAccountsCount :one
select
  COUNT(*) as account_count
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  a.owner_id = $1::uuid
  or au.user_id is not null
`

func (q *Queries) GetUserAccountsCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUserAccountsCount, userID)
	var account_count int64
	err := row.Scan(&account_count)
	return account_count, err
}

const listAccounts = `-- name: ListAccounts :many
select
  a.id,
  a.owner_id,
  a.name,
  a.bank,
  a.account_type,
  a.alias,
  a.anchor_date,
  a.anchor_balance,
  a.balance,
  a.main_currency,
  a.colors,
  a.created_at,
  a.updated_at,
  (a.owner_id = $1::uuid) as is_owner
from
  accounts a
  left join account_users au on au.account_id = a.id
  and au.user_id = $1::uuid
where
  a.owner_id = $1::uuid
  or au.user_id is not null
order by
  is_owner desc,
  a.created_at
`

type ListAccountsRow struct {
	ID            int64             `json:"id"`
	OwnerID       uuid.UUID         `json:"owner_id"`
	Name          string            `json:"name"`
	Bank          string            `json:"bank"`
	AccountType   arian.AccountType `json:"account_type"`
	Alias         *string           `json:"alias"`
	AnchorDate    time.Time         `json:"anchor_date"`
	AnchorBalance *types.Money      `json:"anchor_balance"`
	Balance       []byte            `json:"balance"`
	MainCurrency  string            `json:"main_currency"`
	Colors        []string          `json:"colors"`
	CreatedAt     time.Time         `json:"created_at"`
	UpdatedAt     time.Time         `json:"updated_at"`
	IsOwner       bool              `json:"is_owner"`
}

func (q *Queries) ListAccounts(ctx context.Context, userID uuid.UUID) ([]ListAccountsRow, error) {
	rows, err := q.db.Query(ctx, listAccounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsRow
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Bank,
			&i.AccountType,
			&i.Alias,
			&i.AnchorDate,
			&i.AnchorBalance,
			&i.Balance,
			&i.MainCurrency,
			&i.Colors,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAccountAnchor = `-- name: SetAccountAnchor :execrows
update
  accounts
set
  anchor_date = now()::date,
  anchor_balance = $1::jsonb
where
  id = $2::bigint
`

type SetAccountAnchorParams struct {
	AnchorBalance []byte `json:"anchor_balance"`
	ID            int64  `json:"id"`
}

func (q *Queries) SetAccountAnchor(ctx context.Context, arg SetAccountAnchorParams) (int64, error) {
	result, err := q.db.Exec(ctx, setAccountAnchor, arg.AnchorBalance, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateAccount = `-- name: UpdateAccount :one
update
  accounts
set
  name = COALESCE($1::text, name),
  bank = COALESCE($2::text, bank),
  account_type = COALESCE(
    $3::smallint,
    account_type
  ),
  alias = COALESCE($4::text, alias),
  anchor_date = COALESCE($5::date, anchor_date),
  anchor_balance = COALESCE(
    $6::jsonb,
    anchor_balance
  ),
  balance = COALESCE($7::jsonb, balance),
  main_currency = COALESCE($8::text, main_currency),
  colors = COALESCE($9::text [], colors)
where
  id = $10::bigint
returning
  id, owner_id, name, bank, account_type, alias, anchor_date, anchor_balance, created_at, updated_at, main_currency, colors, balance
`

type UpdateAccountParams struct {
	Name          *string    `json:"name"`
	Bank          *string    `json:"bank"`
	AccountType   *int16     `json:"account_type"`
	Alias         *string    `json:"alias"`
	AnchorDate    *time.Time `json:"anchor_date"`
	AnchorBalance []byte     `json:"anchor_balance"`
	Balance       []byte     `json:"balance"`
	MainCurrency  *string    `json:"main_currency"`
	Colors        []string   `json:"colors"`
	ID            int64      `json:"id"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorDate,
		arg.AnchorBalance,
		arg.Balance,
		arg.MainCurrency,
		arg.Colors,
		arg.ID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainCurrency,
		&i.Colors,
		&i.Balance,
	)
	return i, err
}
