// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package sqlc

import (
	"context"
	"time"

	"ariand/internal/types"
	"github.com/google/uuid"
)

const checkUserAccountAccess = `-- name: CheckUserAccountAccess :one
select
  exists(
    select
      1
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $1::uuid
    where
      a.id = $2::bigint
      and (
        a.owner_id = $1::uuid
        or au.user_id is not null
      )
  ) as has_access
`

type CheckUserAccountAccessParams struct {
	UserID    uuid.UUID `db:"user_id" json:"user_id"`
	AccountID int64     `db:"account_id" json:"account_id"`
}

func (q *Queries) CheckUserAccountAccess(ctx context.Context, arg CheckUserAccountAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserAccountAccess, arg.UserID, arg.AccountID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const createAccount = `-- name: CreateAccount :one
insert into
  accounts (
    owner_id,
    name,
    bank,
    account_type,
    alias,
    anchor_balance,
    balance,
    main_currency,
    colors
  )
values
  (
    $1::uuid,
    $2::text,
    $3::text,
    $4::smallint,
    $5::text,
    $6::jsonb,
    $6::jsonb,
    $7::text,
    $8::text []
  )
returning
  id, owner_id, name, bank, account_type, alias, anchor_date, anchor_balance, created_at, updated_at, main_currency, colors, balance
`

type CreateAccountParams struct {
	OwnerID       uuid.UUID `db:"owner_id" json:"owner_id"`
	Name          string    `db:"name" json:"name"`
	Bank          string    `db:"bank" json:"bank"`
	AccountType   int16     `db:"account_type" json:"account_type"`
	Alias         *string   `db:"alias" json:"alias"`
	AnchorBalance []byte    `db:"anchor_balance" json:"anchor_balance"`
	MainCurrency  string    `db:"main_currency" json:"main_currency"`
	Colors        []string  `db:"colors" json:"colors"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.OwnerID,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorBalance,
		arg.MainCurrency,
		arg.Colors,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainCurrency,
		&i.Colors,
		&i.Balance,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :execrows
delete from
  accounts
where
  id = $1::bigint
  and owner_id = $2::uuid
`

type DeleteAccountParams struct {
	ID     int64     `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteAccount(ctx context.Context, arg DeleteAccountParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAccount, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAccount = `-- name: GetAccount :one
select
  a.id, a.owner_id, a.name, a.bank, a.account_type, a.alias, a.anchor_date, a.anchor_balance, a.created_at, a.updated_at, a.main_currency, a.colors, a.balance
from
  accounts a
  left join account_users au on au.account_id = a.id
  and au.user_id = $1::uuid
where
  a.id = $2::bigint
  and (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
`

type GetAccountParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	ID     int64     `db:"id" json:"id"`
}

func (q *Queries) GetAccount(ctx context.Context, arg GetAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, arg.UserID, arg.ID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainCurrency,
		&i.Colors,
		&i.Balance,
	)
	return i, err
}

const getAccountAnchorBalance = `-- name: GetAccountAnchorBalance :one
select
  anchor_balance
from
  accounts
where
  id = $1::bigint
`

func (q *Queries) GetAccountAnchorBalance(ctx context.Context, id int64) (*types.Money, error) {
	row := q.db.QueryRow(ctx, getAccountAnchorBalance, id)
	var anchor_balance *types.Money
	err := row.Scan(&anchor_balance)
	return anchor_balance, err
}

const getAccountBalance = `-- name: GetAccountBalance :one
select
  balance_after
from
  transactions
where
  account_id = $1::bigint
order by
  tx_date desc,
  id desc
limit
  1
`

func (q *Queries) GetAccountBalance(ctx context.Context, accountID int64) (*types.Money, error) {
	row := q.db.QueryRow(ctx, getAccountBalance, accountID)
	var balance_after *types.Money
	err := row.Scan(&balance_after)
	return balance_after, err
}

const getAccountBalanceSimple = `-- name: GetAccountBalanceSimple :one
select
  balance
from
  accounts
where
  id = $1::bigint
`

func (q *Queries) GetAccountBalanceSimple(ctx context.Context, accountID int64) ([]byte, error) {
	row := q.db.QueryRow(ctx, getAccountBalanceSimple, accountID)
	var balance []byte
	err := row.Scan(&balance)
	return balance, err
}

const getUserAccountsCount = `-- name: GetUserAccountsCount :one
select
  COUNT(*) as account_count
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  a.owner_id = $1::uuid
  or au.user_id is not null
`

func (q *Queries) GetUserAccountsCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUserAccountsCount, userID)
	var account_count int64
	err := row.Scan(&account_count)
	return account_count, err
}

const listAccounts = `-- name: ListAccounts :many
select
  a.id, a.owner_id, a.name, a.bank, a.account_type, a.alias, a.anchor_date, a.anchor_balance, a.created_at, a.updated_at, a.main_currency, a.colors, a.balance
from
  accounts a
  left join account_users au on au.account_id = a.id
  and au.user_id = $1::uuid
where
  a.owner_id = $1::uuid
  or au.user_id is not null
order by
  (a.owner_id = $1::uuid) desc,
  a.created_at
`

func (q *Queries) ListAccounts(ctx context.Context, userID uuid.UUID) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Bank,
			&i.AccountType,
			&i.Alias,
			&i.AnchorDate,
			&i.AnchorBalance,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MainCurrency,
			&i.Colors,
			&i.Balance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAccountAnchor = `-- name: SetAccountAnchor :execrows
update
  accounts
set
  anchor_date = now()::date,
  anchor_balance = $1::jsonb
where
  id = $2::bigint
`

type SetAccountAnchorParams struct {
	AnchorBalance []byte `db:"anchor_balance" json:"anchor_balance"`
	ID            int64  `db:"id" json:"id"`
}

func (q *Queries) SetAccountAnchor(ctx context.Context, arg SetAccountAnchorParams) (int64, error) {
	result, err := q.db.Exec(ctx, setAccountAnchor, arg.AnchorBalance, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateAccount = `-- name: UpdateAccount :one
update
  accounts
set
  name = $1::text,
  bank = $2::text,
  account_type = $3::smallint,
  alias = $4::text,
  anchor_date = $5::date,
  anchor_balance = $6::jsonb,
  balance = $7::jsonb,
  main_currency = $8::text,
  colors = $9::text []
where
  id = $10::bigint
returning
  id, owner_id, name, bank, account_type, alias, anchor_date, anchor_balance, created_at, updated_at, main_currency, colors, balance
`

type UpdateAccountParams struct {
	Name          *string    `db:"name" json:"name"`
	Bank          *string    `db:"bank" json:"bank"`
	AccountType   *int16     `db:"account_type" json:"account_type"`
	Alias         *string    `db:"alias" json:"alias"`
	AnchorDate    *time.Time `db:"anchor_date" json:"anchor_date"`
	AnchorBalance []byte     `db:"anchor_balance" json:"anchor_balance"`
	Balance       []byte     `db:"balance" json:"balance"`
	MainCurrency  *string    `db:"main_currency" json:"main_currency"`
	Colors        []string   `db:"colors" json:"colors"`
	ID            int64      `db:"id" json:"id"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorDate,
		arg.AnchorBalance,
		arg.Balance,
		arg.MainCurrency,
		arg.Colors,
		arg.ID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainCurrency,
		&i.Colors,
		&i.Balance,
	)
	return i, err
}
