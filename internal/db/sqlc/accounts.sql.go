// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: accounts.sql

package sqlcdb

import (
	"context"

	arian "ariand/gen/go/arian/v1"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"google.golang.org/genproto/googleapis/type/date"
	"google.golang.org/genproto/googleapis/type/money"
	"google.golang.org/protobuf/types/known/timestamppb"
)

const checkUserAccountAccess = `-- name: CheckUserAccountAccess :one
SELECT EXISTS(
  SELECT 1 FROM accounts a
  LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
  WHERE a.id = $2::bigint 
    AND (a.owner_id = $1::uuid OR au.user_id IS NOT NULL)
) AS has_access
`

type CheckUserAccountAccessParams struct {
	UserID    uuid.UUID `json:"user_id"`
	AccountID int64     `json:"account_id"`
}

func (q *Queries) CheckUserAccountAccess(ctx context.Context, arg CheckUserAccountAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserAccountAccess, arg.UserID, arg.AccountID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (
  owner_id, name, bank, account_type, alias,
  anchor_balance, anchor_currency
) VALUES (
  $1::uuid,
  $2::text,
  $3::text,
  $4::smallint,
  $5::text,
  $6::numeric,
  $7::char(3)
)
RETURNING id, owner_id, name, bank, account_type, alias,
          anchor_date, anchor_balance, anchor_currency,
          created_at, updated_at
`

type CreateAccountParams struct {
	OwnerID        uuid.UUID       `json:"owner_id"`
	Name           string          `json:"name"`
	Bank           string          `json:"bank"`
	AccountType    int16           `json:"account_type"`
	Alias          *string         `json:"alias"`
	AnchorBalance  decimal.Decimal `json:"anchor_balance"`
	AnchorCurrency string          `json:"anchor_currency"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.OwnerID,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorBalance,
		arg.AnchorCurrency,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.AnchorCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccountForUser = `-- name: DeleteAccountForUser :execrows
DELETE FROM accounts 
WHERE id = $1::bigint AND owner_id = $2::uuid
`

type DeleteAccountForUserParams struct {
	ID     int64     `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteAccountForUser(ctx context.Context, arg DeleteAccountForUserParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAccountForUser, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAccountAnchorBalance = `-- name: GetAccountAnchorBalance :one
SELECT anchor_balance, anchor_currency
FROM accounts
WHERE id = $1::bigint
`

type GetAccountAnchorBalanceRow struct {
	AnchorBalance  *money.Money `json:"anchor_balance"`
	AnchorCurrency string       `json:"anchor_currency"`
}

func (q *Queries) GetAccountAnchorBalance(ctx context.Context, id int64) (GetAccountAnchorBalanceRow, error) {
	row := q.db.QueryRow(ctx, getAccountAnchorBalance, id)
	var i GetAccountAnchorBalanceRow
	err := row.Scan(&i.AnchorBalance, &i.AnchorCurrency)
	return i, err
}

const getAccountBalance = `-- name: GetAccountBalance :one
SELECT balance_after
FROM transactions
WHERE account_id = $1::bigint
ORDER BY tx_date DESC, id DESC
LIMIT 1
`

func (q *Queries) GetAccountBalance(ctx context.Context, accountID int64) (*money.Money, error) {
	row := q.db.QueryRow(ctx, getAccountBalance, accountID)
	var balance_after *money.Money
	err := row.Scan(&balance_after)
	return balance_after, err
}

const getAccountForUser = `-- name: GetAccountForUser :one
SELECT a.id, a.owner_id, a.name, a.bank, a.account_type, a.alias,
       a.anchor_date, a.anchor_balance, a.anchor_currency,
       a.created_at, a.updated_at,
       (a.owner_id = $1::uuid) AS is_owner
FROM accounts a
LEFT JOIN account_users au ON au.account_id = a.id AND au.user_id = $1::uuid
WHERE a.id = $2::bigint
  AND (a.owner_id = $1::uuid OR au.user_id IS NOT NULL)
`

type GetAccountForUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     int64     `json:"id"`
}

type GetAccountForUserRow struct {
	ID             int64                  `json:"id"`
	OwnerID        uuid.UUID              `json:"owner_id"`
	Name           string                 `json:"name"`
	Bank           string                 `json:"bank"`
	AccountType    arian.AccountType      `json:"account_type"`
	Alias          *string                `json:"alias"`
	AnchorDate     *date.Date             `json:"anchor_date"`
	AnchorBalance  *money.Money           `json:"anchor_balance"`
	AnchorCurrency string                 `json:"anchor_currency"`
	CreatedAt      *timestamppb.Timestamp `json:"created_at"`
	UpdatedAt      *timestamppb.Timestamp `json:"updated_at"`
	IsOwner        bool                   `json:"is_owner"`
}

func (q *Queries) GetAccountForUser(ctx context.Context, arg GetAccountForUserParams) (GetAccountForUserRow, error) {
	row := q.db.QueryRow(ctx, getAccountForUser, arg.UserID, arg.ID)
	var i GetAccountForUserRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.AnchorCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsOwner,
	)
	return i, err
}

const getUserAccountsCount = `-- name: GetUserAccountsCount :one
SELECT COUNT(*) AS account_count
FROM accounts a
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
WHERE a.owner_id = $1::uuid OR au.user_id IS NOT NULL
`

func (q *Queries) GetUserAccountsCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUserAccountsCount, userID)
	var account_count int64
	err := row.Scan(&account_count)
	return account_count, err
}

const listAccountsForUser = `-- name: ListAccountsForUser :many
SELECT a.id, a.owner_id, a.name, a.bank, a.account_type, a.alias,
       a.anchor_date, a.anchor_balance, a.anchor_currency,
       a.created_at, a.updated_at,
       (a.owner_id = $1::uuid) AS is_owner
FROM accounts a
LEFT JOIN account_users au ON au.account_id = a.id AND au.user_id = $1::uuid
WHERE a.owner_id = $1::uuid OR au.user_id IS NOT NULL
ORDER BY is_owner DESC, a.created_at
`

type ListAccountsForUserRow struct {
	ID             int64                  `json:"id"`
	OwnerID        uuid.UUID              `json:"owner_id"`
	Name           string                 `json:"name"`
	Bank           string                 `json:"bank"`
	AccountType    arian.AccountType      `json:"account_type"`
	Alias          *string                `json:"alias"`
	AnchorDate     *date.Date             `json:"anchor_date"`
	AnchorBalance  *money.Money           `json:"anchor_balance"`
	AnchorCurrency string                 `json:"anchor_currency"`
	CreatedAt      *timestamppb.Timestamp `json:"created_at"`
	UpdatedAt      *timestamppb.Timestamp `json:"updated_at"`
	IsOwner        bool                   `json:"is_owner"`
}

func (q *Queries) ListAccountsForUser(ctx context.Context, userID uuid.UUID) ([]ListAccountsForUserRow, error) {
	rows, err := q.db.Query(ctx, listAccountsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsForUserRow
	for rows.Next() {
		var i ListAccountsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Bank,
			&i.AccountType,
			&i.Alias,
			&i.AnchorDate,
			&i.AnchorBalance,
			&i.AnchorCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAccountAnchor = `-- name: SetAccountAnchor :execrows
UPDATE accounts
SET anchor_date = NOW()::date,
    anchor_balance = $1::numeric,
    anchor_currency = $2::char(3)
WHERE id = $3::bigint
`

type SetAccountAnchorParams struct {
	AnchorBalance  decimal.Decimal `json:"anchor_balance"`
	AnchorCurrency string          `json:"anchor_currency"`
	ID             int64           `json:"id"`
}

func (q *Queries) SetAccountAnchor(ctx context.Context, arg SetAccountAnchorParams) (int64, error) {
	result, err := q.db.Exec(ctx, setAccountAnchor, arg.AnchorBalance, arg.AnchorCurrency, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET name = COALESCE($1::text, name),
    bank = COALESCE($2::text, bank),
    account_type = COALESCE($3::smallint, account_type),
    alias = COALESCE($4::text, alias),
    anchor_date = COALESCE($5::date, anchor_date),
    anchor_balance = COALESCE($6::numeric, anchor_balance),
    anchor_currency = COALESCE($7::char(3), anchor_currency)
WHERE id = $8::bigint
RETURNING id, owner_id, name, bank, account_type, alias,
          anchor_date, anchor_balance, anchor_currency,
          created_at, updated_at
`

type UpdateAccountParams struct {
	Name           *string          `json:"name"`
	Bank           *string          `json:"bank"`
	AccountType    *int16           `json:"account_type"`
	Alias          *string          `json:"alias"`
	AnchorDate     *date.Date       `json:"anchor_date"`
	AnchorBalance  *decimal.Decimal `json:"anchor_balance"`
	AnchorCurrency *string          `json:"anchor_currency"`
	ID             int64            `json:"id"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorDate,
		arg.AnchorBalance,
		arg.AnchorCurrency,
		arg.ID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.AnchorCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
