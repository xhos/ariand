// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: accounts.sql

package sqlcdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (name, bank, account_type, alias, anchor_balance, anchor_currency)
VALUES ($1::text, $2::text, $3::text,
        $4::text,
        $5::numeric, $6::char(3))
RETURNING id, name, bank, account_type, alias,
          anchor_date, anchor_balance, anchor_currency,
          created_at, updated_at
`

type CreateAccountParams struct {
	Name           string          `json:"name"`
	Bank           string          `json:"bank"`
	AccountType    string          `json:"accountType"`
	Alias          *string         `json:"alias"`
	AnchorBalance  decimal.Decimal `json:"anchorBalance"`
	AnchorCurrency string          `json:"anchorCurrency"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorBalance,
		arg.AnchorCurrency,
	)
	var i Account
	err := row.Scan(
		&i.Id,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.AnchorCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :execrows
DELETE FROM accounts WHERE id = $1::bigint
`

func (q *Queries) DeleteAccount(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAccount, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAccount = `-- name: GetAccount :one
SELECT id, name, bank, account_type, alias,
       anchor_date, anchor_balance, anchor_currency,
       created_at, updated_at
FROM accounts
WHERE id = $1::bigint
`

func (q *Queries) GetAccount(ctx context.Context, id int64) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.Id,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.AnchorCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountAnchorBalance = `-- name: GetAccountAnchorBalance :one
SELECT anchor_balance 
FROM accounts 
WHERE id = $1::bigint
`

func (q *Queries) GetAccountAnchorBalance(ctx context.Context, id int64) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, getAccountAnchorBalance, id)
	var anchor_balance decimal.Decimal
	err := row.Scan(&anchor_balance)
	return anchor_balance, err
}

const getAccountBalance = `-- name: GetAccountBalance :one
SELECT balance_after 
FROM transactions 
WHERE account_id = $1::bigint 
ORDER BY tx_date DESC, id DESC 
LIMIT 1
`

func (q *Queries) GetAccountBalance(ctx context.Context, accountID int64) (*decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, getAccountBalance, accountID)
	var balance_after *decimal.Decimal
	err := row.Scan(&balance_after)
	return balance_after, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, name, bank, account_type, alias,
       anchor_date, anchor_balance, anchor_currency,
       created_at, updated_at
FROM accounts
ORDER BY created_at
`

func (q *Queries) ListAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.Id,
			&i.Name,
			&i.Bank,
			&i.AccountType,
			&i.Alias,
			&i.AnchorDate,
			&i.AnchorBalance,
			&i.AnchorCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAccountAnchor = `-- name: SetAccountAnchor :execrows
UPDATE accounts
SET anchor_date     = NOW()::date,
    anchor_balance  = $1::numeric,
    anchor_currency = $2::char(3)
WHERE id = $3::bigint
`

type SetAccountAnchorParams struct {
	AnchorBalance  decimal.Decimal `json:"anchorBalance"`
	AnchorCurrency string          `json:"anchorCurrency"`
	Id             int64           `json:"id"`
}

func (q *Queries) SetAccountAnchor(ctx context.Context, arg SetAccountAnchorParams) (int64, error) {
	result, err := q.db.Exec(ctx, setAccountAnchor, arg.AnchorBalance, arg.AnchorCurrency, arg.Id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateAccountPartial = `-- name: UpdateAccountPartial :one
UPDATE accounts
SET name            = CASE WHEN $1::bool            THEN $2::text               ELSE name            END,
    bank            = CASE WHEN $3::bool            THEN $4::text               ELSE bank            END,
    account_type    = CASE WHEN $5::bool            THEN $6::text       ELSE account_type    END,
    alias           = CASE WHEN $7::bool           THEN $8::text  ELSE alias           END,
    anchor_date     = CASE WHEN $9::bool     THEN $10::date        ELSE anchor_date     END,
    anchor_balance  = CASE WHEN $11::bool  THEN $12::numeric  ELSE anchor_balance  END,
    anchor_currency = CASE WHEN $13::bool THEN $14::char(3) ELSE anchor_currency END
WHERE id = $15::bigint
RETURNING id, name, bank, account_type, alias,
          anchor_date, anchor_balance, anchor_currency,
          created_at, updated_at
`

type UpdateAccountPartialParams struct {
	NameSet           bool            `json:"nameSet"`
	Name              string          `json:"name"`
	BankSet           bool            `json:"bankSet"`
	Bank              string          `json:"bank"`
	TypeSet           bool            `json:"typeSet"`
	AccountType       string          `json:"accountType"`
	AliasSet          bool            `json:"aliasSet"`
	Alias             *string         `json:"alias"`
	AnchorDateSet     bool            `json:"anchorDateSet"`
	AnchorDate        pgtype.Date     `json:"anchorDate"`
	AnchorBalanceSet  bool            `json:"anchorBalanceSet"`
	AnchorBalance     decimal.Decimal `json:"anchorBalance"`
	AnchorCurrencySet bool            `json:"anchorCurrencySet"`
	AnchorCurrency    string          `json:"anchorCurrency"`
	Id                int64           `json:"id"`
}

func (q *Queries) UpdateAccountPartial(ctx context.Context, arg UpdateAccountPartialParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccountPartial,
		arg.NameSet,
		arg.Name,
		arg.BankSet,
		arg.Bank,
		arg.TypeSet,
		arg.AccountType,
		arg.AliasSet,
		arg.Alias,
		arg.AnchorDateSet,
		arg.AnchorDate,
		arg.AnchorBalanceSet,
		arg.AnchorBalance,
		arg.AnchorCurrencySet,
		arg.AnchorCurrency,
		arg.Id,
	)
	var i Account
	err := row.Scan(
		&i.Id,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.AnchorCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
