// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rules.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const bulkApplyRuleToTransactions = `-- name: BulkApplyRuleToTransactions :execrows
update transactions
set
  category_id = coalesce($1::bigint, category_id),
  merchant = coalesce($2::text, merchant)
where id = ANY($3::bigint[])
  and account_id in (
    select a.id
    from accounts a
    left join account_users au on a.id = au.account_id and au.user_id = $4::uuid
    where a.owner_id = $4::uuid or au.user_id is not null
  )
  and category_manually_set = false
  and merchant_manually_set = false
`

type BulkApplyRuleToTransactionsParams struct {
	CategoryID     int64     `json:"category_id"`
	Merchant       string    `json:"merchant"`
	TransactionIds []int64   `json:"transaction_ids"`
	UserID         uuid.UUID `json:"user_id"`
}

func (q *Queries) BulkApplyRuleToTransactions(ctx context.Context, arg BulkApplyRuleToTransactionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkApplyRuleToTransactions,
		arg.CategoryID,
		arg.Merchant,
		arg.TransactionIds,
		arg.UserID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createRule = `-- name: CreateRule :one
insert into transaction_rules (user_id, rule_name, category_id, conditions, merchant)
values ($1::uuid, $2::text, $3::bigint, $4::jsonb, $5::text)
returning rule_id, user_id, rule_name, category_id, conditions, is_active, priority_order, rule_source, created_at, updated_at, last_applied_at, times_applied, merchant
`

type CreateRuleParams struct {
	UserID     uuid.UUID `json:"user_id"`
	RuleName   string    `json:"rule_name"`
	CategoryID int64     `json:"category_id"`
	Conditions []byte    `json:"conditions"`
	Merchant   string    `json:"merchant"`
}

func (q *Queries) CreateRule(ctx context.Context, arg CreateRuleParams) (TransactionRule, error) {
	row := q.db.QueryRow(ctx, createRule,
		arg.UserID,
		arg.RuleName,
		arg.CategoryID,
		arg.Conditions,
		arg.Merchant,
	)
	var i TransactionRule
	err := row.Scan(
		&i.RuleID,
		&i.UserID,
		&i.RuleName,
		&i.CategoryID,
		&i.Conditions,
		&i.IsActive,
		&i.PriorityOrder,
		&i.RuleSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAppliedAt,
		&i.TimesApplied,
		&i.Merchant,
	)
	return i, err
}

const deleteRule = `-- name: DeleteRule :execrows
delete from transaction_rules
where rule_id = $1::uuid
  and user_id = $2::uuid
`

type DeleteRuleParams struct {
	RuleID uuid.UUID `json:"rule_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteRule(ctx context.Context, arg DeleteRuleParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRule, arg.RuleID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getActiveRules = `-- name: GetActiveRules :many
select rule_id, user_id, rule_name, category_id, conditions, is_active, priority_order, rule_source, created_at, updated_at, last_applied_at, times_applied, merchant
from transaction_rules
where user_id = $1::uuid
  and (is_active is null or is_active = true)
order by priority_order, created_at
`

func (q *Queries) GetActiveRules(ctx context.Context, userID uuid.UUID) ([]TransactionRule, error) {
	rows, err := q.db.Query(ctx, getActiveRules, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransactionRule
	for rows.Next() {
		var i TransactionRule
		if err := rows.Scan(
			&i.RuleID,
			&i.UserID,
			&i.RuleName,
			&i.CategoryID,
			&i.Conditions,
			&i.IsActive,
			&i.PriorityOrder,
			&i.RuleSource,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastAppliedAt,
			&i.TimesApplied,
			&i.Merchant,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRule = `-- name: GetRule :one
select rule_id, user_id, rule_name, category_id, conditions, is_active, priority_order, rule_source, created_at, updated_at, last_applied_at, times_applied, merchant
from transaction_rules
where rule_id = $1::uuid
  and user_id = $2::uuid
`

type GetRuleParams struct {
	RuleID uuid.UUID `json:"rule_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetRule(ctx context.Context, arg GetRuleParams) (TransactionRule, error) {
	row := q.db.QueryRow(ctx, getRule, arg.RuleID, arg.UserID)
	var i TransactionRule
	err := row.Scan(
		&i.RuleID,
		&i.UserID,
		&i.RuleName,
		&i.CategoryID,
		&i.Conditions,
		&i.IsActive,
		&i.PriorityOrder,
		&i.RuleSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAppliedAt,
		&i.TimesApplied,
		&i.Merchant,
	)
	return i, err
}

const getTransactionsForRuleApplication = `-- name: GetTransactionsForRuleApplication :many
select
  t.id, t.account_id, t.email_id, t.tx_date, t.tx_amount, t.tx_direction, t.tx_desc, t.balance_after, t.merchant, t.category_id, t.suggestions, t.user_notes, t.foreign_amount, t.exchange_rate, t.receipt_id, t.created_at, t.updated_at, t.category_manually_set, t.merchant_manually_set
from transactions t
join accounts a on t.account_id = a.id
left join account_users au on a.id = au.account_id and au.user_id = $1::uuid
where (a.owner_id = $1::uuid or au.user_id is not null)
  and ($2::bigint[] is null or t.id = ANY($2::bigint[]))
  and ($3::boolean = true or (t.category_manually_set = false and t.merchant_manually_set = false))
`

type GetTransactionsForRuleApplicationParams struct {
	UserID             uuid.UUID `json:"user_id"`
	TransactionIds     []int64   `json:"transaction_ids"`
	IncludeManuallySet *bool     `json:"include_manually_set"`
}

func (q *Queries) GetTransactionsForRuleApplication(ctx context.Context, arg GetTransactionsForRuleApplicationParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsForRuleApplication, arg.UserID, arg.TransactionIds, arg.IncludeManuallySet)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.EmailID,
			&i.TxDate,
			&i.TxAmount,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfter,
			&i.Merchant,
			&i.CategoryID,
			&i.Suggestions,
			&i.UserNotes,
			&i.ForeignAmount,
			&i.ExchangeRate,
			&i.ReceiptID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryManuallySet,
			&i.MerchantManuallySet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRules = `-- name: ListRules :many
select rule_id, user_id, rule_name, category_id, conditions, is_active, priority_order, rule_source, created_at, updated_at, last_applied_at, times_applied, merchant
from transaction_rules
where user_id = $1::uuid
order by priority_order, created_at
`

func (q *Queries) ListRules(ctx context.Context, userID uuid.UUID) ([]TransactionRule, error) {
	rows, err := q.db.Query(ctx, listRules, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransactionRule
	for rows.Next() {
		var i TransactionRule
		if err := rows.Scan(
			&i.RuleID,
			&i.UserID,
			&i.RuleName,
			&i.CategoryID,
			&i.Conditions,
			&i.IsActive,
			&i.PriorityOrder,
			&i.RuleSource,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastAppliedAt,
			&i.TimesApplied,
			&i.Merchant,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRule = `-- name: UpdateRule :one
update transaction_rules
set
  rule_name = $1,
  category_id = $2::bigint,
  conditions = $3,
  is_active = $4,
  priority_order = $5,
  merchant = $6,
  updated_at = now()
where rule_id = $7::uuid
  and user_id = $8::uuid
returning rule_id, user_id, rule_name, category_id, conditions, is_active, priority_order, rule_source, created_at, updated_at, last_applied_at, times_applied, merchant
`

type UpdateRuleParams struct {
	RuleName      *string   `json:"rule_name"`
	CategoryID    *int64    `json:"category_id"`
	Conditions    []byte    `json:"conditions"`
	IsActive      *bool     `json:"is_active"`
	PriorityOrder *int32    `json:"priority_order"`
	Merchant      *string   `json:"merchant"`
	RuleID        uuid.UUID `json:"rule_id"`
	UserID        uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateRule(ctx context.Context, arg UpdateRuleParams) (TransactionRule, error) {
	row := q.db.QueryRow(ctx, updateRule,
		arg.RuleName,
		arg.CategoryID,
		arg.Conditions,
		arg.IsActive,
		arg.PriorityOrder,
		arg.Merchant,
		arg.RuleID,
		arg.UserID,
	)
	var i TransactionRule
	err := row.Scan(
		&i.RuleID,
		&i.UserID,
		&i.RuleName,
		&i.CategoryID,
		&i.Conditions,
		&i.IsActive,
		&i.PriorityOrder,
		&i.RuleSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAppliedAt,
		&i.TimesApplied,
		&i.Merchant,
	)
	return i, err
}
