// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rules.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const createRule = `-- name: CreateRule :one
insert into transaction_rules (user_id, rule_name, category_id, conditions, merchant)
values ($1::uuid, $2::text, $3::bigint, $4::jsonb, $5::text)
returning rule_id, user_id, rule_name, category_id, conditions, is_active, priority_order, rule_source, created_at, updated_at, last_applied_at, times_applied, merchant
`

type CreateRuleParams struct {
	UserID     uuid.UUID `json:"user_id"`
	RuleName   string    `json:"rule_name"`
	CategoryID int64     `json:"category_id"`
	Conditions []byte    `json:"conditions"`
	Merchant   string    `json:"merchant"`
}

func (q *Queries) CreateRule(ctx context.Context, arg CreateRuleParams) (TransactionRule, error) {
	row := q.db.QueryRow(ctx, createRule,
		arg.UserID,
		arg.RuleName,
		arg.CategoryID,
		arg.Conditions,
		arg.Merchant,
	)
	var i TransactionRule
	err := row.Scan(
		&i.RuleID,
		&i.UserID,
		&i.RuleName,
		&i.CategoryID,
		&i.Conditions,
		&i.IsActive,
		&i.PriorityOrder,
		&i.RuleSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAppliedAt,
		&i.TimesApplied,
		&i.Merchant,
	)
	return i, err
}

const deleteRule = `-- name: DeleteRule :execrows
delete from transaction_rules
where rule_id = $1::uuid
  and user_id = $2::uuid
`

type DeleteRuleParams struct {
	RuleID uuid.UUID `json:"rule_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteRule(ctx context.Context, arg DeleteRuleParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRule, arg.RuleID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getRule = `-- name: GetRule :one
select rule_id, user_id, rule_name, category_id, conditions, is_active, priority_order, rule_source, created_at, updated_at, last_applied_at, times_applied, merchant
from transaction_rules
where rule_id = $1::uuid
  and user_id = $2::uuid
`

type GetRuleParams struct {
	RuleID uuid.UUID `json:"rule_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetRule(ctx context.Context, arg GetRuleParams) (TransactionRule, error) {
	row := q.db.QueryRow(ctx, getRule, arg.RuleID, arg.UserID)
	var i TransactionRule
	err := row.Scan(
		&i.RuleID,
		&i.UserID,
		&i.RuleName,
		&i.CategoryID,
		&i.Conditions,
		&i.IsActive,
		&i.PriorityOrder,
		&i.RuleSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAppliedAt,
		&i.TimesApplied,
		&i.Merchant,
	)
	return i, err
}

const listRules = `-- name: ListRules :many
select rule_id, user_id, rule_name, category_id, conditions, is_active, priority_order, rule_source, created_at, updated_at, last_applied_at, times_applied, merchant
from transaction_rules
where user_id = $1::uuid
order by priority_order, created_at
`

func (q *Queries) ListRules(ctx context.Context, userID uuid.UUID) ([]TransactionRule, error) {
	rows, err := q.db.Query(ctx, listRules, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransactionRule
	for rows.Next() {
		var i TransactionRule
		if err := rows.Scan(
			&i.RuleID,
			&i.UserID,
			&i.RuleName,
			&i.CategoryID,
			&i.Conditions,
			&i.IsActive,
			&i.PriorityOrder,
			&i.RuleSource,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastAppliedAt,
			&i.TimesApplied,
			&i.Merchant,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRule = `-- name: UpdateRule :one
update transaction_rules
set
  rule_name = $1,
  category_id = $2::bigint,
  conditions = $3,
  is_active = $4,
  priority_order = $5,
  merchant = $6,
  updated_at = now()
where rule_id = $7::uuid
  and user_id = $8::uuid
returning rule_id, user_id, rule_name, category_id, conditions, is_active, priority_order, rule_source, created_at, updated_at, last_applied_at, times_applied, merchant
`

type UpdateRuleParams struct {
	RuleName      *string   `json:"rule_name"`
	CategoryID    *int64    `json:"category_id"`
	Conditions    []byte    `json:"conditions"`
	IsActive      *bool     `json:"is_active"`
	PriorityOrder *int32    `json:"priority_order"`
	Merchant      *string   `json:"merchant"`
	RuleID        uuid.UUID `json:"rule_id"`
	UserID        uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateRule(ctx context.Context, arg UpdateRuleParams) (TransactionRule, error) {
	row := q.db.QueryRow(ctx, updateRule,
		arg.RuleName,
		arg.CategoryID,
		arg.Conditions,
		arg.IsActive,
		arg.PriorityOrder,
		arg.Merchant,
		arg.RuleID,
		arg.UserID,
	)
	var i TransactionRule
	err := row.Scan(
		&i.RuleID,
		&i.UserID,
		&i.RuleName,
		&i.CategoryID,
		&i.Conditions,
		&i.IsActive,
		&i.PriorityOrder,
		&i.RuleSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAppliedAt,
		&i.TimesApplied,
		&i.Merchant,
	)
	return i, err
}
