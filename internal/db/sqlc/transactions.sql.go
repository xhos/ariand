// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package sqlc

import (
	"context"
	"time"

	arian "ariand/internal/gen/arian/v1"
	"ariand/internal/types"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const bulkCategorizeTransactions = `-- name: BulkCategorizeTransactions :execrows
UPDATE transactions
SET category_id = $1::bigint,
    cat_status = 3  -- manual categorization
WHERE id = ANY($2::bigint[])
  AND account_id IN (
    SELECT a.id FROM accounts a
    LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $3::uuid
    WHERE a.owner_id = $3::uuid OR au.user_id IS NOT NULL
  )
`

type BulkCategorizeTransactionsParams struct {
	CategoryID     int64     `json:"category_id"`
	TransactionIds []int64   `json:"transaction_ids"`
	UserID         uuid.UUID `json:"user_id"`
}

func (q *Queries) BulkCategorizeTransactions(ctx context.Context, arg BulkCategorizeTransactionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkCategorizeTransactions, arg.CategoryID, arg.TransactionIds, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const bulkDeleteTransactions = `-- name: BulkDeleteTransactions :execrows
DELETE FROM transactions
WHERE id = ANY($1::bigint[])
  AND account_id IN (
    SELECT a.id FROM accounts a
    LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $2::uuid
    WHERE a.owner_id = $2::uuid OR au.user_id IS NOT NULL
  )
`

type BulkDeleteTransactionsParams struct {
	TransactionIds []int64   `json:"transaction_ids"`
	UserID         uuid.UUID `json:"user_id"`
}

func (q *Queries) BulkDeleteTransactions(ctx context.Context, arg BulkDeleteTransactionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkDeleteTransactions, arg.TransactionIds, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const categorizeTransactionAtomic = `-- name: CategorizeTransactionAtomic :one
UPDATE transactions
SET category_id = $1::bigint,
    cat_status = $2::smallint,
    suggestions = $3::text[]
WHERE id = $4::bigint
  AND cat_status = 0  -- Only update if still uncategorized
  AND account_id IN (
    SELECT a.id FROM accounts a
    LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $5::uuid
    WHERE a.owner_id = $5::uuid OR au.user_id IS NOT NULL
  )
RETURNING id, cat_status
`

type CategorizeTransactionAtomicParams struct {
	CategoryID  *int64    `json:"category_id"`
	CatStatus   int16     `json:"cat_status"`
	Suggestions []string  `json:"suggestions"`
	ID          int64     `json:"id"`
	UserID      uuid.UUID `json:"user_id"`
}

type CategorizeTransactionAtomicRow struct {
	ID        int64                      `json:"id"`
	CatStatus arian.CategorizationStatus `json:"cat_status"`
}

func (q *Queries) CategorizeTransactionAtomic(ctx context.Context, arg CategorizeTransactionAtomicParams) (CategorizeTransactionAtomicRow, error) {
	row := q.db.QueryRow(ctx, categorizeTransactionAtomic,
		arg.CategoryID,
		arg.CatStatus,
		arg.Suggestions,
		arg.ID,
		arg.UserID,
	)
	var i CategorizeTransactionAtomicRow
	err := row.Scan(&i.ID, &i.CatStatus)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
  email_id, account_id, tx_date, tx_amount, tx_direction,
  tx_desc, balance_after, category_id, merchant, user_notes,
  foreign_amount, exchange_rate, suggestions, receipt_id
)
SELECT
  $1::text,
  $2::bigint,
  $3::timestamptz,
  $4::jsonb,
  $5::smallint,
  $6::text,
  $7::jsonb,
  $8::bigint,
  $9::text,
  $10::text,
  $11::jsonb,
  $12::numeric,
  $13::text[],
  $14::bigint
FROM accounts a
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $15::uuid
WHERE a.id = $2::bigint
  AND (a.owner_id = $15::uuid OR au.user_id IS NOT NULL)
RETURNING id
`

type CreateTransactionParams struct {
	EmailID       *string          `json:"email_id"`
	AccountID     int64            `json:"account_id"`
	TxDate        time.Time        `json:"tx_date"`
	TxAmount      []byte           `json:"tx_amount"`
	TxDirection   int16            `json:"tx_direction"`
	TxDesc        *string          `json:"tx_desc"`
	BalanceAfter  []byte           `json:"balance_after"`
	CategoryID    *int64           `json:"category_id"`
	Merchant      *string          `json:"merchant"`
	UserNotes     *string          `json:"user_notes"`
	ForeignAmount []byte           `json:"foreign_amount"`
	ExchangeRate  *decimal.Decimal `json:"exchange_rate"`
	Suggestions   []string         `json:"suggestions"`
	ReceiptID     *int64           `json:"receipt_id"`
	UserID        uuid.UUID        `json:"user_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.EmailID,
		arg.AccountID,
		arg.TxDate,
		arg.TxAmount,
		arg.TxDirection,
		arg.TxDesc,
		arg.BalanceAfter,
		arg.CategoryID,
		arg.Merchant,
		arg.UserNotes,
		arg.ForeignAmount,
		arg.ExchangeRate,
		arg.Suggestions,
		arg.ReceiptID,
		arg.UserID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteTransaction = `-- name: DeleteTransaction :one
DELETE FROM transactions
WHERE id = $1::bigint
  AND account_id IN (
    SELECT a.id FROM accounts a
    LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $2::uuid
    WHERE a.owner_id = $2::uuid OR au.user_id IS NOT NULL
  )
RETURNING account_id
`

type DeleteTransactionParams struct {
	ID     int64     `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteTransaction(ctx context.Context, arg DeleteTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteTransaction, arg.ID, arg.UserID)
	var account_id int64
	err := row.Scan(&account_id)
	return account_id, err
}

const findCandidateTransactions = `-- name: FindCandidateTransactions :many
SELECT
  t.id, t.email_id, t.account_id, t.tx_date, t.tx_amount,
  t.tx_direction, t.tx_desc, t.balance_after, t.category_id, t.cat_status,
  t.merchant, t.user_notes, t.suggestions, t.receipt_id,
  t.foreign_amount, t.exchange_rate,
  t.created_at, t.updated_at,
  c.slug AS category_slug,
  c.label AS category_label,
  c.color AS category_color,
  similarity(t.tx_desc::text, $1::text) AS merchant_score
FROM transactions t
LEFT JOIN categories c ON t.category_id = c.id
JOIN accounts a ON t.account_id = a.id
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $2::uuid
WHERE (a.owner_id = $2::uuid OR au.user_id IS NOT NULL)
  AND t.receipt_id IS NULL
  AND t.tx_direction = 2
  AND t.tx_date >= ($3::date - interval '60 days')
  AND (t.tx_amount->>'units')::bigint + (t.tx_amount->>'nanos')::bigint/1000000000.0 BETWEEN $4::numeric AND ($4::numeric * 1.20)
  AND similarity(t.tx_desc::text, $1::text) > 0.3
ORDER BY merchant_score DESC
LIMIT 10
`

type FindCandidateTransactionsParams struct {
	Merchant string          `json:"merchant"`
	UserID   uuid.UUID       `json:"user_id"`
	Date     time.Time       `json:"date"`
	Total    decimal.Decimal `json:"total"`
}

type FindCandidateTransactionsRow struct {
	ID            int64                      `json:"id"`
	EmailID       *string                    `json:"email_id"`
	AccountID     int64                      `json:"account_id"`
	TxDate        time.Time                  `json:"tx_date"`
	TxAmount      *types.MoneyWrapper        `json:"tx_amount"`
	TxDirection   arian.TransactionDirection `json:"tx_direction"`
	TxDesc        *string                    `json:"tx_desc"`
	BalanceAfter  *types.MoneyWrapper        `json:"balance_after"`
	CategoryID    *int64                     `json:"category_id"`
	CatStatus     arian.CategorizationStatus `json:"cat_status"`
	Merchant      *string                    `json:"merchant"`
	UserNotes     *string                    `json:"user_notes"`
	Suggestions   []string                   `json:"suggestions"`
	ReceiptID     *int64                     `json:"receipt_id"`
	ForeignAmount *types.MoneyWrapper        `json:"foreign_amount"`
	ExchangeRate  *decimal.Decimal           `json:"exchange_rate"`
	CreatedAt     time.Time                  `json:"created_at"`
	UpdatedAt     time.Time                  `json:"updated_at"`
	CategorySlug  *string                    `json:"category_slug"`
	CategoryLabel *string                    `json:"category_label"`
	CategoryColor *string                    `json:"category_color"`
	MerchantScore float32                    `json:"merchant_score"`
}

func (q *Queries) FindCandidateTransactions(ctx context.Context, arg FindCandidateTransactionsParams) ([]FindCandidateTransactionsRow, error) {
	rows, err := q.db.Query(ctx, findCandidateTransactions,
		arg.Merchant,
		arg.UserID,
		arg.Date,
		arg.Total,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCandidateTransactionsRow
	for rows.Next() {
		var i FindCandidateTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.EmailID,
			&i.AccountID,
			&i.TxDate,
			&i.TxAmount,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfter,
			&i.CategoryID,
			&i.CatStatus,
			&i.Merchant,
			&i.UserNotes,
			&i.Suggestions,
			&i.ReceiptID,
			&i.ForeignAmount,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategorySlug,
			&i.CategoryLabel,
			&i.CategoryColor,
			&i.MerchantScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
SELECT
  t.id, t.email_id, t.account_id, t.tx_date, t.tx_amount,
  t.tx_direction, t.tx_desc, t.balance_after, t.category_id, t.cat_status,
  t.merchant, t.user_notes, t.suggestions, t.receipt_id,
  t.foreign_amount, t.exchange_rate,
  t.created_at, t.updated_at,
  c.slug AS category_slug,
  c.label AS category_label,
  c.color AS category_color,
  a.name AS account_name
FROM transactions t
LEFT JOIN categories c ON t.category_id = c.id
JOIN accounts a ON t.account_id = a.id
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
WHERE t.id = $2::bigint
  AND (a.owner_id = $1::uuid OR au.user_id IS NOT NULL)
`

type GetTransactionParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     int64     `json:"id"`
}

type GetTransactionRow struct {
	ID            int64                      `json:"id"`
	EmailID       *string                    `json:"email_id"`
	AccountID     int64                      `json:"account_id"`
	TxDate        time.Time                  `json:"tx_date"`
	TxAmount      *types.MoneyWrapper        `json:"tx_amount"`
	TxDirection   arian.TransactionDirection `json:"tx_direction"`
	TxDesc        *string                    `json:"tx_desc"`
	BalanceAfter  *types.MoneyWrapper        `json:"balance_after"`
	CategoryID    *int64                     `json:"category_id"`
	CatStatus     arian.CategorizationStatus `json:"cat_status"`
	Merchant      *string                    `json:"merchant"`
	UserNotes     *string                    `json:"user_notes"`
	Suggestions   []string                   `json:"suggestions"`
	ReceiptID     *int64                     `json:"receipt_id"`
	ForeignAmount *types.MoneyWrapper        `json:"foreign_amount"`
	ExchangeRate  *decimal.Decimal           `json:"exchange_rate"`
	CreatedAt     time.Time                  `json:"created_at"`
	UpdatedAt     time.Time                  `json:"updated_at"`
	CategorySlug  *string                    `json:"category_slug"`
	CategoryLabel *string                    `json:"category_label"`
	CategoryColor *string                    `json:"category_color"`
	AccountName   string                     `json:"account_name"`
}

func (q *Queries) GetTransaction(ctx context.Context, arg GetTransactionParams) (GetTransactionRow, error) {
	row := q.db.QueryRow(ctx, getTransaction, arg.UserID, arg.ID)
	var i GetTransactionRow
	err := row.Scan(
		&i.ID,
		&i.EmailID,
		&i.AccountID,
		&i.TxDate,
		&i.TxAmount,
		&i.TxDirection,
		&i.TxDesc,
		&i.BalanceAfter,
		&i.CategoryID,
		&i.CatStatus,
		&i.Merchant,
		&i.UserNotes,
		&i.Suggestions,
		&i.ReceiptID,
		&i.ForeignAmount,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategorySlug,
		&i.CategoryLabel,
		&i.CategoryColor,
		&i.AccountName,
	)
	return i, err
}

const getTransactionCountByAccount = `-- name: GetTransactionCountByAccount :many
SELECT a.id, a.name, COUNT(t.id) AS transaction_count
FROM accounts a
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
LEFT JOIN transactions t ON a.id = t.account_id
WHERE a.owner_id = $1::uuid OR au.user_id IS NOT NULL
GROUP BY a.id, a.name
ORDER BY transaction_count DESC
`

type GetTransactionCountByAccountRow struct {
	ID               int64  `json:"id"`
	Name             string `json:"name"`
	TransactionCount int64  `json:"transaction_count"`
}

func (q *Queries) GetTransactionCountByAccount(ctx context.Context, userID uuid.UUID) ([]GetTransactionCountByAccountRow, error) {
	rows, err := q.db.Query(ctx, getTransactionCountByAccount, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionCountByAccountRow
	for rows.Next() {
		var i GetTransactionCountByAccountRow
		if err := rows.Scan(&i.ID, &i.Name, &i.TransactionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT
  t.id, t.email_id, t.account_id, t.tx_date, t.tx_amount,
  t.tx_direction, t.tx_desc, t.balance_after, t.category_id, t.cat_status,
  t.merchant, t.user_notes, t.suggestions, t.receipt_id,
  t.foreign_amount, t.exchange_rate,
  t.created_at, t.updated_at,
  c.slug AS category_slug,
  c.label AS category_label,
  c.color AS category_color,
  a.name AS account_name
FROM transactions t
LEFT JOIN categories c ON t.category_id = c.id
JOIN accounts a ON t.account_id = a.id
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
WHERE (a.owner_id = $1::uuid OR au.user_id IS NOT NULL)
  AND (
        $2::timestamptz IS NULL
        OR $3::bigint IS NULL
        OR (t.tx_date, t.id) < ($2::timestamptz, $3::bigint)
      )
  AND ($4::timestamptz IS NULL OR t.tx_date >= $4::timestamptz)
  AND ($5::timestamptz IS NULL OR t.tx_date <= $5::timestamptz)
  AND ($6::numeric IS NULL OR (t.tx_amount->>'units')::bigint >= $6::numeric)
  AND ($7::numeric IS NULL OR (t.tx_amount->>'units')::bigint <= $7::numeric)
  AND ($8::smallint IS NULL OR t.tx_direction = $8::smallint)
  AND ($9::bigint[] IS NULL OR t.account_id = ANY($9::bigint[]))
  AND ($10::text[] IS NULL OR c.slug = ANY($10::text[]))
  AND ($11::text IS NULL OR t.merchant ILIKE ('%' || $11::text || '%'))
  AND ($12::text IS NULL OR t.tx_desc ILIKE ('%' || $12::text || '%'))
  AND ($13::char(3) IS NULL OR t.tx_amount->>'currency_code' = $13::char(3))
  AND ($14::time IS NULL OR t.tx_date::time >= $14::time)
  AND ($15::time IS NULL OR t.tx_date::time <= $15::time)
  AND ($16::boolean IS NULL OR ($16::boolean = true AND t.category_id IS NULL))
ORDER BY t.tx_date DESC, t.id DESC
LIMIT COALESCE($17::int, 100)
`

type ListTransactionsParams struct {
	UserID        uuid.UUID        `json:"user_id"`
	CursorDate    *time.Time       `json:"cursor_date"`
	CursorID      *int64           `json:"cursor_id"`
	Start         *time.Time       `json:"start"`
	End           *time.Time       `json:"end"`
	AmountMin     *decimal.Decimal `json:"amount_min"`
	AmountMax     *decimal.Decimal `json:"amount_max"`
	Direction     *int16           `json:"direction"`
	AccountIds    []int64          `json:"account_ids"`
	Categories    []string         `json:"categories"`
	MerchantQ     *string          `json:"merchant_q"`
	DescQ         *string          `json:"desc_q"`
	Currency      *string          `json:"currency"`
	TodStart      pgtype.Time      `json:"tod_start"`
	TodEnd        pgtype.Time      `json:"tod_end"`
	Uncategorized *bool            `json:"uncategorized"`
	Limit         *int32           `json:"limit"`
}

type ListTransactionsRow struct {
	ID            int64                      `json:"id"`
	EmailID       *string                    `json:"email_id"`
	AccountID     int64                      `json:"account_id"`
	TxDate        time.Time                  `json:"tx_date"`
	TxAmount      *types.MoneyWrapper        `json:"tx_amount"`
	TxDirection   arian.TransactionDirection `json:"tx_direction"`
	TxDesc        *string                    `json:"tx_desc"`
	BalanceAfter  *types.MoneyWrapper        `json:"balance_after"`
	CategoryID    *int64                     `json:"category_id"`
	CatStatus     arian.CategorizationStatus `json:"cat_status"`
	Merchant      *string                    `json:"merchant"`
	UserNotes     *string                    `json:"user_notes"`
	Suggestions   []string                   `json:"suggestions"`
	ReceiptID     *int64                     `json:"receipt_id"`
	ForeignAmount *types.MoneyWrapper        `json:"foreign_amount"`
	ExchangeRate  *decimal.Decimal           `json:"exchange_rate"`
	CreatedAt     time.Time                  `json:"created_at"`
	UpdatedAt     time.Time                  `json:"updated_at"`
	CategorySlug  *string                    `json:"category_slug"`
	CategoryLabel *string                    `json:"category_label"`
	CategoryColor *string                    `json:"category_color"`
	AccountName   string                     `json:"account_name"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]ListTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.UserID,
		arg.CursorDate,
		arg.CursorID,
		arg.Start,
		arg.End,
		arg.AmountMin,
		arg.AmountMax,
		arg.Direction,
		arg.AccountIds,
		arg.Categories,
		arg.MerchantQ,
		arg.DescQ,
		arg.Currency,
		arg.TodStart,
		arg.TodEnd,
		arg.Uncategorized,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTransactionsRow
	for rows.Next() {
		var i ListTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.EmailID,
			&i.AccountID,
			&i.TxDate,
			&i.TxAmount,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfter,
			&i.CategoryID,
			&i.CatStatus,
			&i.Merchant,
			&i.UserNotes,
			&i.Suggestions,
			&i.ReceiptID,
			&i.ForeignAmount,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategorySlug,
			&i.CategoryLabel,
			&i.CategoryColor,
			&i.AccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTransactionReceipt = `-- name: SetTransactionReceipt :execrows
UPDATE transactions
SET receipt_id = $1::bigint
WHERE id = $2::bigint AND receipt_id IS NULL
`

type SetTransactionReceiptParams struct {
	ReceiptID int64 `json:"receipt_id"`
	ID        int64 `json:"id"`
}

func (q *Queries) SetTransactionReceipt(ctx context.Context, arg SetTransactionReceiptParams) (int64, error) {
	result, err := q.db.Exec(ctx, setTransactionReceipt, arg.ReceiptID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const syncAccountBalances = `-- name: SyncAccountBalances :exec
WITH transaction_deltas AS (
  SELECT id,
         SUM(CASE WHEN tx_direction = 1 THEN (tx_amount->>'units')::bigint + (tx_amount->>'nanos')::bigint/1000000000.0 
                  ELSE -((tx_amount->>'units')::bigint + (tx_amount->>'nanos')::bigint/1000000000.0) END)
           OVER (PARTITION BY account_id ORDER BY tx_date, id) AS running_delta
  FROM transactions
  WHERE account_id = $1::bigint
),
anchor_point AS (
  SELECT a.anchor_balance,
         COALESCE(SUM(CASE WHEN t.tx_direction = 1 THEN (t.tx_amount->>'units')::bigint + (t.tx_amount->>'nanos')::bigint/1000000000.0 
                           ELSE -((t.tx_amount->>'units')::bigint + (t.tx_amount->>'nanos')::bigint/1000000000.0) END), 0.0) AS delta_at_anchor
  FROM accounts a
  LEFT JOIN transactions t ON t.account_id = a.id AND t.tx_date < a.anchor_date
  WHERE a.id = $1::bigint
  GROUP BY a.id, a.anchor_balance
)
UPDATE transactions
SET balance_after = jsonb_build_object(
  'currency_code', tx_amount->>'currency_code',
  'units', ((ap.anchor_balance->>'units')::bigint + td.running_delta - ap.delta_at_anchor)::bigint,
  'nanos', 0
)
FROM transaction_deltas td, anchor_point ap
WHERE transactions.id = td.id
  AND transactions.account_id = $1::bigint
`

func (q *Queries) SyncAccountBalances(ctx context.Context, accountID int64) error {
	_, err := q.db.Exec(ctx, syncAccountBalances, accountID)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions
SET email_id = COALESCE($1::text, email_id),
    tx_date = COALESCE($2::timestamptz, tx_date),
    tx_amount = COALESCE($3::jsonb, tx_amount),
    tx_direction = COALESCE($4::smallint, tx_direction),
    tx_desc = COALESCE($5::text, tx_desc),
    category_id = COALESCE($6::bigint, category_id),
    merchant = COALESCE($7::text, merchant),
    user_notes = COALESCE($8::text, user_notes),
    foreign_amount = COALESCE($9::jsonb, foreign_amount),
    exchange_rate = COALESCE($10::numeric, exchange_rate),
    suggestions = COALESCE($11::text[], suggestions),
    receipt_id = COALESCE($12::bigint, receipt_id),
    cat_status = COALESCE($13::smallint, cat_status)
WHERE id = $14::bigint
  AND account_id IN (
    SELECT a.id FROM accounts a
    LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $15::uuid
    WHERE a.owner_id = $15::uuid OR au.user_id IS NOT NULL
  )
RETURNING account_id
`

type UpdateTransactionParams struct {
	EmailID       *string          `json:"email_id"`
	TxDate        *time.Time       `json:"tx_date"`
	TxAmount      []byte           `json:"tx_amount"`
	TxDirection   *int16           `json:"tx_direction"`
	TxDesc        *string          `json:"tx_desc"`
	CategoryID    *int64           `json:"category_id"`
	Merchant      *string          `json:"merchant"`
	UserNotes     *string          `json:"user_notes"`
	ForeignAmount []byte           `json:"foreign_amount"`
	ExchangeRate  *decimal.Decimal `json:"exchange_rate"`
	Suggestions   []string         `json:"suggestions"`
	ReceiptID     *int64           `json:"receipt_id"`
	CatStatus     *int16           `json:"cat_status"`
	ID            int64            `json:"id"`
	UserID        uuid.UUID        `json:"user_id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateTransaction,
		arg.EmailID,
		arg.TxDate,
		arg.TxAmount,
		arg.TxDirection,
		arg.TxDesc,
		arg.CategoryID,
		arg.Merchant,
		arg.UserNotes,
		arg.ForeignAmount,
		arg.ExchangeRate,
		arg.Suggestions,
		arg.ReceiptID,
		arg.CatStatus,
		arg.ID,
		arg.UserID,
	)
	var account_id int64
	err := row.Scan(&account_id)
	return account_id, err
}
