// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package sqlc

import (
	"context"
	"time"

	arian "ariand/internal/gen/arian/v1"
	"ariand/internal/types"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const bulkCategorizeTransactions = `-- name: BulkCategorizeTransactions :execrows
update
  transactions
set
  category_id = $1::bigint,
  category_manually_set = true -- manual categorization
where
  id = ANY($2::bigint [])
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $3::uuid
    where
      a.owner_id = $3::uuid
      or au.user_id is not null
  )
`

type BulkCategorizeTransactionsParams struct {
	CategoryID     int64     `json:"category_id"`
	TransactionIds []int64   `json:"transaction_ids"`
	UserID         uuid.UUID `json:"user_id"`
}

func (q *Queries) BulkCategorizeTransactions(ctx context.Context, arg BulkCategorizeTransactionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkCategorizeTransactions, arg.CategoryID, arg.TransactionIds, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const bulkDeleteTransactions = `-- name: BulkDeleteTransactions :execrows
delete from
  transactions
where
  id = ANY($1::bigint [])
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $2::uuid
    where
      a.owner_id = $2::uuid
      or au.user_id is not null
  )
`

type BulkDeleteTransactionsParams struct {
	TransactionIds []int64   `json:"transaction_ids"`
	UserID         uuid.UUID `json:"user_id"`
}

func (q *Queries) BulkDeleteTransactions(ctx context.Context, arg BulkDeleteTransactionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkDeleteTransactions, arg.TransactionIds, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const categorizeTransactionAtomic = `-- name: CategorizeTransactionAtomic :one
update
  transactions
set
  category_id = $1::bigint,
  category_manually_set = $2::boolean,
  suggestions = $3::text []
where
  id = $4::bigint
  and category_manually_set = false -- Only update if not manually set
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $5::uuid
    where
      a.owner_id = $5::uuid
      or au.user_id is not null
  )
returning
  id,
  category_manually_set
`

type CategorizeTransactionAtomicParams struct {
	CategoryID          *int64    `json:"category_id"`
	CategoryManuallySet bool      `json:"category_manually_set"`
	Suggestions         []string  `json:"suggestions"`
	ID                  int64     `json:"id"`
	UserID              uuid.UUID `json:"user_id"`
}

type CategorizeTransactionAtomicRow struct {
	ID                  int64 `json:"id"`
	CategoryManuallySet bool  `json:"category_manually_set"`
}

func (q *Queries) CategorizeTransactionAtomic(ctx context.Context, arg CategorizeTransactionAtomicParams) (CategorizeTransactionAtomicRow, error) {
	row := q.db.QueryRow(ctx, categorizeTransactionAtomic,
		arg.CategoryID,
		arg.CategoryManuallySet,
		arg.Suggestions,
		arg.ID,
		arg.UserID,
	)
	var i CategorizeTransactionAtomicRow
	err := row.Scan(&i.ID, &i.CategoryManuallySet)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
insert into
  transactions (
    email_id,
    account_id,
    tx_date,
    tx_amount,
    tx_direction,
    tx_desc,
    balance_after,
    category_id,
    category_manually_set,
    merchant,
    merchant_manually_set,
    user_notes,
    foreign_amount,
    exchange_rate,
    suggestions,
    receipt_id
  )
select
  $1::text,
  $2::bigint,
  $3::timestamptz,
  $4::jsonb,
  $5::smallint,
  $6::text,
  $7::jsonb,
  $8::bigint,
  $9::boolean,
  $10::text,
  $11::boolean,
  $12::text,
  $13::jsonb,
  $14::numeric,
  $15::text [],
  $16::bigint
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $17::uuid
where
  a.id = $2::bigint
  and (
    a.owner_id = $17::uuid
    or au.user_id is not null
  )
returning
  id
`

type CreateTransactionParams struct {
	EmailID             *string          `json:"email_id"`
	AccountID           int64            `json:"account_id"`
	TxDate              time.Time        `json:"tx_date"`
	TxAmount            []byte           `json:"tx_amount"`
	TxDirection         int16            `json:"tx_direction"`
	TxDesc              *string          `json:"tx_desc"`
	BalanceAfter        []byte           `json:"balance_after"`
	CategoryID          *int64           `json:"category_id"`
	CategoryManuallySet *bool            `json:"category_manually_set"`
	Merchant            *string          `json:"merchant"`
	MerchantManuallySet *bool            `json:"merchant_manually_set"`
	UserNotes           *string          `json:"user_notes"`
	ForeignAmount       []byte           `json:"foreign_amount"`
	ExchangeRate        *decimal.Decimal `json:"exchange_rate"`
	Suggestions         []string         `json:"suggestions"`
	ReceiptID           *int64           `json:"receipt_id"`
	UserID              uuid.UUID        `json:"user_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.EmailID,
		arg.AccountID,
		arg.TxDate,
		arg.TxAmount,
		arg.TxDirection,
		arg.TxDesc,
		arg.BalanceAfter,
		arg.CategoryID,
		arg.CategoryManuallySet,
		arg.Merchant,
		arg.MerchantManuallySet,
		arg.UserNotes,
		arg.ForeignAmount,
		arg.ExchangeRate,
		arg.Suggestions,
		arg.ReceiptID,
		arg.UserID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteTransaction = `-- name: DeleteTransaction :one
delete from
  transactions
where
  id = $1::bigint
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $2::uuid
    where
      a.owner_id = $2::uuid
      or au.user_id is not null
  )
returning
  account_id
`

type DeleteTransactionParams struct {
	ID     int64     `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteTransaction(ctx context.Context, arg DeleteTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteTransaction, arg.ID, arg.UserID)
	var account_id int64
	err := row.Scan(&account_id)
	return account_id, err
}

const findCandidateTransactions = `-- name: FindCandidateTransactions :many
select
  t.id,
  t.email_id,
  t.account_id,
  t.tx_date,
  t.tx_amount,
  t.tx_direction,
  t.tx_desc,
  t.balance_after,
  t.category_id,
  t.category_manually_set,
  t.merchant,
  t.merchant_manually_set,
  t.user_notes,
  t.suggestions,
  t.receipt_id,
  t.foreign_amount,
  t.exchange_rate,
  t.created_at,
  t.updated_at,
  c.slug as category_slug,
  c.color as category_color,
  similarity(t.tx_desc::text, $1::text) as merchant_score
from
  transactions t
  left join categories c on t.category_id = c.id
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $2::uuid
where
  (
    a.owner_id = $2::uuid
    or au.user_id is not null
  )
  and t.receipt_id is null
  and t.tx_direction = 2
  and t.tx_date >= ($3::date - interval '60 days')
  and (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0 between $4::numeric and ($4::numeric * 1.20)
  and similarity(t.tx_desc::text, $1::text) > 0.3
order by
  merchant_score desc
limit
  10
`

type FindCandidateTransactionsParams struct {
	Merchant string          `json:"merchant"`
	UserID   uuid.UUID       `json:"user_id"`
	Date     time.Time       `json:"date"`
	Total    decimal.Decimal `json:"total"`
}

type FindCandidateTransactionsRow struct {
	ID                  int64                      `json:"id"`
	EmailID             *string                    `json:"email_id"`
	AccountID           int64                      `json:"account_id"`
	TxDate              time.Time                  `json:"tx_date"`
	TxAmount            *types.Money               `json:"tx_amount"`
	TxDirection         arian.TransactionDirection `json:"tx_direction"`
	TxDesc              *string                    `json:"tx_desc"`
	BalanceAfter        *types.Money               `json:"balance_after"`
	CategoryID          *int64                     `json:"category_id"`
	CategoryManuallySet bool                       `json:"category_manually_set"`
	Merchant            *string                    `json:"merchant"`
	MerchantManuallySet bool                       `json:"merchant_manually_set"`
	UserNotes           *string                    `json:"user_notes"`
	Suggestions         []string                   `json:"suggestions"`
	ReceiptID           *int64                     `json:"receipt_id"`
	ForeignAmount       *types.Money               `json:"foreign_amount"`
	ExchangeRate        *decimal.Decimal           `json:"exchange_rate"`
	CreatedAt           time.Time                  `json:"created_at"`
	UpdatedAt           time.Time                  `json:"updated_at"`
	CategorySlug        *string                    `json:"category_slug"`
	CategoryColor       *string                    `json:"category_color"`
	MerchantScore       float32                    `json:"merchant_score"`
}

func (q *Queries) FindCandidateTransactions(ctx context.Context, arg FindCandidateTransactionsParams) ([]FindCandidateTransactionsRow, error) {
	rows, err := q.db.Query(ctx, findCandidateTransactions,
		arg.Merchant,
		arg.UserID,
		arg.Date,
		arg.Total,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCandidateTransactionsRow
	for rows.Next() {
		var i FindCandidateTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.EmailID,
			&i.AccountID,
			&i.TxDate,
			&i.TxAmount,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfter,
			&i.CategoryID,
			&i.CategoryManuallySet,
			&i.Merchant,
			&i.MerchantManuallySet,
			&i.UserNotes,
			&i.Suggestions,
			&i.ReceiptID,
			&i.ForeignAmount,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategorySlug,
			&i.CategoryColor,
			&i.MerchantScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountIDsFromTransactionIDs = `-- name: GetAccountIDsFromTransactionIDs :many
select
  distinct account_id
from
  transactions
where
  id = ANY($1::bigint [])
`

func (q *Queries) GetAccountIDsFromTransactionIDs(ctx context.Context, ids []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAccountIDsFromTransactionIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var account_id int64
		if err := rows.Scan(&account_id); err != nil {
			return nil, err
		}
		items = append(items, account_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
select
  t.id,
  t.email_id,
  t.account_id,
  t.tx_date,
  t.tx_amount,
  t.tx_direction,
  t.tx_desc,
  t.balance_after,
  t.category_id,
  t.category_manually_set,
  t.merchant,
  t.merchant_manually_set,
  t.user_notes,
  t.suggestions,
  t.receipt_id,
  t.foreign_amount,
  t.exchange_rate,
  t.created_at,
  t.updated_at,
  c.slug as category_slug,
  c.color as category_color,
  a.name as account_name
from
  transactions t
  left join categories c on t.category_id = c.id
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  t.id = $2::bigint
  and (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
`

type GetTransactionParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     int64     `json:"id"`
}

type GetTransactionRow struct {
	ID                  int64                      `json:"id"`
	EmailID             *string                    `json:"email_id"`
	AccountID           int64                      `json:"account_id"`
	TxDate              time.Time                  `json:"tx_date"`
	TxAmount            *types.Money               `json:"tx_amount"`
	TxDirection         arian.TransactionDirection `json:"tx_direction"`
	TxDesc              *string                    `json:"tx_desc"`
	BalanceAfter        *types.Money               `json:"balance_after"`
	CategoryID          *int64                     `json:"category_id"`
	CategoryManuallySet bool                       `json:"category_manually_set"`
	Merchant            *string                    `json:"merchant"`
	MerchantManuallySet bool                       `json:"merchant_manually_set"`
	UserNotes           *string                    `json:"user_notes"`
	Suggestions         []string                   `json:"suggestions"`
	ReceiptID           *int64                     `json:"receipt_id"`
	ForeignAmount       *types.Money               `json:"foreign_amount"`
	ExchangeRate        *decimal.Decimal           `json:"exchange_rate"`
	CreatedAt           time.Time                  `json:"created_at"`
	UpdatedAt           time.Time                  `json:"updated_at"`
	CategorySlug        *string                    `json:"category_slug"`
	CategoryColor       *string                    `json:"category_color"`
	AccountName         string                     `json:"account_name"`
}

func (q *Queries) GetTransaction(ctx context.Context, arg GetTransactionParams) (GetTransactionRow, error) {
	row := q.db.QueryRow(ctx, getTransaction, arg.UserID, arg.ID)
	var i GetTransactionRow
	err := row.Scan(
		&i.ID,
		&i.EmailID,
		&i.AccountID,
		&i.TxDate,
		&i.TxAmount,
		&i.TxDirection,
		&i.TxDesc,
		&i.BalanceAfter,
		&i.CategoryID,
		&i.CategoryManuallySet,
		&i.Merchant,
		&i.MerchantManuallySet,
		&i.UserNotes,
		&i.Suggestions,
		&i.ReceiptID,
		&i.ForeignAmount,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategorySlug,
		&i.CategoryColor,
		&i.AccountName,
	)
	return i, err
}

const getTransactionCountByAccount = `-- name: GetTransactionCountByAccount :many
select
  a.id,
  a.name,
  COUNT(t.id) as transaction_count
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
  left join transactions t on a.id = t.account_id
where
  a.owner_id = $1::uuid
  or au.user_id is not null
group by
  a.id,
  a.name
order by
  transaction_count desc
`

type GetTransactionCountByAccountRow struct {
	ID               int64  `json:"id"`
	Name             string `json:"name"`
	TransactionCount int64  `json:"transaction_count"`
}

func (q *Queries) GetTransactionCountByAccount(ctx context.Context, userID uuid.UUID) ([]GetTransactionCountByAccountRow, error) {
	rows, err := q.db.Query(ctx, getTransactionCountByAccount, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionCountByAccountRow
	for rows.Next() {
		var i GetTransactionCountByAccountRow
		if err := rows.Scan(&i.ID, &i.Name, &i.TransactionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
select
  t.id,
  t.email_id,
  t.account_id,
  t.tx_date,
  t.tx_amount,
  t.tx_direction,
  t.tx_desc,
  t.balance_after,
  t.category_id,
  t.category_manually_set,
  t.merchant,
  t.merchant_manually_set,
  t.user_notes,
  t.suggestions,
  t.receipt_id,
  t.foreign_amount,
  t.exchange_rate,
  t.created_at,
  t.updated_at,
  c.slug as category_slug,
  c.color as category_color,
  a.name as account_name
from
  transactions t
  left join categories c on t.category_id = c.id
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
  and (
    $2::timestamptz is null
    or $3::bigint is null
    or (t.tx_date, t.id) < (
      $2::timestamptz,
      $3::bigint
    )
  )
  and (
    $4::timestamptz is null
    or t.tx_date >= $4::timestamptz
  )
  and (
    $5::timestamptz is null
    or t.tx_date <= $5::timestamptz
  )
  and (
    $6::numeric is null
    or (t.tx_amount ->> 'units')::bigint >= $6::numeric
  )
  and (
    $7::numeric is null
    or (t.tx_amount ->> 'units')::bigint <= $7::numeric
  )
  and (
    $8::smallint is null
    or t.tx_direction = $8::smallint
  )
  and (
    $9::bigint [] is null
    or t.account_id = ANY($9::bigint [])
  )
  and (
    $10::text [] is null
    or c.slug = ANY($10::text [])
  )
  and (
    $11::text is null
    or t.merchant ILIKE ('%' || $11::text || '%')
  )
  and (
    $12::text is null
    or t.tx_desc ILIKE ('%' || $12::text || '%')
  )
  and (
    $13::char(3) is null
    or t.tx_amount ->> 'currency_code' = $13::char(3)
  )
  and (
    $14::time is null
    or t.tx_date::time >= $14::time
  )
  and (
    $15::time is null
    or t.tx_date::time <= $15::time
  )
  and (
    $16::boolean is null
    or (
      $16::boolean = true
      and t.category_id is null
    )
  )
order by
  t.tx_date desc,
  t.id desc
limit
  COALESCE($17::int, 100)
`

type ListTransactionsParams struct {
	UserID        uuid.UUID        `json:"user_id"`
	CursorDate    *time.Time       `json:"cursor_date"`
	CursorID      *int64           `json:"cursor_id"`
	Start         *time.Time       `json:"start"`
	End           *time.Time       `json:"end"`
	AmountMin     *decimal.Decimal `json:"amount_min"`
	AmountMax     *decimal.Decimal `json:"amount_max"`
	Direction     *int16           `json:"direction"`
	AccountIds    []int64          `json:"account_ids"`
	Categories    []string         `json:"categories"`
	MerchantQ     *string          `json:"merchant_q"`
	DescQ         *string          `json:"desc_q"`
	Currency      *string          `json:"currency"`
	TodStart      pgtype.Time      `json:"tod_start"`
	TodEnd        pgtype.Time      `json:"tod_end"`
	Uncategorized *bool            `json:"uncategorized"`
	Limit         *int32           `json:"limit"`
}

type ListTransactionsRow struct {
	ID                  int64                      `json:"id"`
	EmailID             *string                    `json:"email_id"`
	AccountID           int64                      `json:"account_id"`
	TxDate              time.Time                  `json:"tx_date"`
	TxAmount            *types.Money               `json:"tx_amount"`
	TxDirection         arian.TransactionDirection `json:"tx_direction"`
	TxDesc              *string                    `json:"tx_desc"`
	BalanceAfter        *types.Money               `json:"balance_after"`
	CategoryID          *int64                     `json:"category_id"`
	CategoryManuallySet bool                       `json:"category_manually_set"`
	Merchant            *string                    `json:"merchant"`
	MerchantManuallySet bool                       `json:"merchant_manually_set"`
	UserNotes           *string                    `json:"user_notes"`
	Suggestions         []string                   `json:"suggestions"`
	ReceiptID           *int64                     `json:"receipt_id"`
	ForeignAmount       *types.Money               `json:"foreign_amount"`
	ExchangeRate        *decimal.Decimal           `json:"exchange_rate"`
	CreatedAt           time.Time                  `json:"created_at"`
	UpdatedAt           time.Time                  `json:"updated_at"`
	CategorySlug        *string                    `json:"category_slug"`
	CategoryColor       *string                    `json:"category_color"`
	AccountName         string                     `json:"account_name"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]ListTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.UserID,
		arg.CursorDate,
		arg.CursorID,
		arg.Start,
		arg.End,
		arg.AmountMin,
		arg.AmountMax,
		arg.Direction,
		arg.AccountIds,
		arg.Categories,
		arg.MerchantQ,
		arg.DescQ,
		arg.Currency,
		arg.TodStart,
		arg.TodEnd,
		arg.Uncategorized,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTransactionsRow
	for rows.Next() {
		var i ListTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.EmailID,
			&i.AccountID,
			&i.TxDate,
			&i.TxAmount,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfter,
			&i.CategoryID,
			&i.CategoryManuallySet,
			&i.Merchant,
			&i.MerchantManuallySet,
			&i.UserNotes,
			&i.Suggestions,
			&i.ReceiptID,
			&i.ForeignAmount,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategorySlug,
			&i.CategoryColor,
			&i.AccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recalculateBalancesAfterTransaction = `-- name: RecalculateBalancesAfterTransaction :exec
with transaction_deltas as (
  select
    id,
    SUM(
      case
        when tx_direction = 1 then (tx_amount ->> 'units')::bigint + (tx_amount ->> 'nanos')::bigint / 1000000000.0
        else -(
          (tx_amount ->> 'units')::bigint + (tx_amount ->> 'nanos')::bigint / 1000000000.0
        )
      end
    ) OVER (
      partition BY account_id
      order by
        tx_date,
        id
    ) as running_delta
  from
    transactions
  where
    account_id = $1::bigint
    and (
      tx_date > $2::timestamptz
      or (
        tx_date = $2::timestamptz
        and id >= $3::bigint
      )
    )
),
anchor_point as (
  select
    a.anchor_balance,
    COALESCE(
      SUM(
        case
          when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
          else -(
            (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
          )
        end
      ),
      0.0
    ) as delta_at_anchor
  from
    accounts a
    left join transactions t on t.account_id = a.id
    and t.tx_date < a.anchor_date
  where
    a.id = $1::bigint
  group by
    a.id,
    a.anchor_balance
)
update
  transactions
set
  balance_after = jsonb_build_object(
    'currency_code',
    tx_amount ->> 'currency_code',
    'units',
    (
      (ap.anchor_balance ->> 'units')::bigint + td.running_delta - ap.delta_at_anchor
    )::bigint,
    'nanos',
    0
  )
from
  transaction_deltas td,
  anchor_point ap
where
  transactions.id = td.id
  and transactions.account_id = $1::bigint
`

type RecalculateBalancesAfterTransactionParams struct {
	AccountID int64     `json:"account_id"`
	FromDate  time.Time `json:"from_date"`
	FromID    int64     `json:"from_id"`
}

// Recalculate balance_after for all transactions after a given date/id
func (q *Queries) RecalculateBalancesAfterTransaction(ctx context.Context, arg RecalculateBalancesAfterTransactionParams) error {
	_, err := q.db.Exec(ctx, recalculateBalancesAfterTransaction, arg.AccountID, arg.FromDate, arg.FromID)
	return err
}

const setTransactionReceipt = `-- name: SetTransactionReceipt :execrows
update
  transactions
set
  receipt_id = $1::bigint
where
  id = $2::bigint
  and receipt_id is null
`

type SetTransactionReceiptParams struct {
	ReceiptID int64 `json:"receipt_id"`
	ID        int64 `json:"id"`
}

func (q *Queries) SetTransactionReceipt(ctx context.Context, arg SetTransactionReceiptParams) (int64, error) {
	result, err := q.db.Exec(ctx, setTransactionReceipt, arg.ReceiptID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const syncAccountBalances = `-- name: SyncAccountBalances :exec
with transaction_deltas as (
  select
    id,
    SUM(
      case
        when tx_direction = 1 then (tx_amount ->> 'units')::bigint + (tx_amount ->> 'nanos')::bigint / 1000000000.0
        else -(
          (tx_amount ->> 'units')::bigint + (tx_amount ->> 'nanos')::bigint / 1000000000.0
        )
      end
    ) OVER (
      partition BY account_id
      order by
        tx_date,
        id
    ) as running_delta
  from
    transactions
  where
    account_id = $1::bigint
),
anchor_point as (
  select
    a.anchor_balance,
    COALESCE(
      SUM(
        case
          when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
          else -(
            (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
          )
        end
      ),
      0.0
    ) as delta_at_anchor
  from
    accounts a
    left join transactions t on t.account_id = a.id
    and t.tx_date < a.anchor_date
  where
    a.id = $1::bigint
  group by
    a.id,
    a.anchor_balance
)
update
  transactions
set
  balance_after = jsonb_build_object(
    'currency_code',
    tx_amount ->> 'currency_code',
    'units',
    (
      (ap.anchor_balance ->> 'units')::bigint + td.running_delta - ap.delta_at_anchor
    )::bigint,
    'nanos',
    0
  )
from
  transaction_deltas td,
  anchor_point ap
where
  transactions.id = td.id
  and transactions.account_id = $1::bigint
`

func (q *Queries) SyncAccountBalances(ctx context.Context, accountID int64) error {
	_, err := q.db.Exec(ctx, syncAccountBalances, accountID)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :one
update
  transactions
set
  email_id = COALESCE($1::text, email_id),
  tx_date = COALESCE($2::timestamptz, tx_date),
  tx_amount = COALESCE($3::jsonb, tx_amount),
  tx_direction = COALESCE(
    $4::smallint,
    tx_direction
  ),
  tx_desc = COALESCE($5::text, tx_desc),
  category_id = COALESCE($6::bigint, category_id),
  merchant = COALESCE($7::text, merchant),
  user_notes = COALESCE($8::text, user_notes),
  foreign_amount = COALESCE(
    $9::jsonb,
    foreign_amount
  ),
  exchange_rate = COALESCE(
    $10::numeric,
    exchange_rate
  ),
  suggestions = COALESCE($11::text [], suggestions),
  receipt_id = COALESCE($12::bigint, receipt_id),
  category_manually_set = COALESCE($13::boolean, category_manually_set),
  merchant_manually_set = COALESCE($14::boolean, merchant_manually_set)
where
  id = $15::bigint
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $16::uuid
    where
      a.owner_id = $16::uuid
      or au.user_id is not null
  )
returning
  account_id
`

type UpdateTransactionParams struct {
	EmailID             *string          `json:"email_id"`
	TxDate              *time.Time       `json:"tx_date"`
	TxAmount            []byte           `json:"tx_amount"`
	TxDirection         *int16           `json:"tx_direction"`
	TxDesc              *string          `json:"tx_desc"`
	CategoryID          *int64           `json:"category_id"`
	Merchant            *string          `json:"merchant"`
	UserNotes           *string          `json:"user_notes"`
	ForeignAmount       []byte           `json:"foreign_amount"`
	ExchangeRate        *decimal.Decimal `json:"exchange_rate"`
	Suggestions         []string         `json:"suggestions"`
	ReceiptID           *int64           `json:"receipt_id"`
	CategoryManuallySet *bool            `json:"category_manually_set"`
	MerchantManuallySet *bool            `json:"merchant_manually_set"`
	ID                  int64            `json:"id"`
	UserID              uuid.UUID        `json:"user_id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateTransaction,
		arg.EmailID,
		arg.TxDate,
		arg.TxAmount,
		arg.TxDirection,
		arg.TxDesc,
		arg.CategoryID,
		arg.Merchant,
		arg.UserNotes,
		arg.ForeignAmount,
		arg.ExchangeRate,
		arg.Suggestions,
		arg.ReceiptID,
		arg.CategoryManuallySet,
		arg.MerchantManuallySet,
		arg.ID,
		arg.UserID,
	)
	var account_id int64
	err := row.Scan(&account_id)
	return account_id, err
}
