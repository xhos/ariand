// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package sqlcdb

import (
	"context"

	ariand "ariand/gen/go/ariand/v1"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
  email_id, account_id, tx_date, tx_amount, tx_currency, tx_direction,
  tx_desc, balance_after, category_id, merchant, user_notes,
  foreign_currency, foreign_amount, exchange_rate, suggestions, receipt_id
) VALUES (
  $1::text,
  $2::bigint,
  $3::timestamptz,
  $4::numeric,
  $5::char(3),
  $6::text,
  $7::text,
  $8::numeric,
  $9::bigint,
  $10::text,
  $11::text,
  $12::char(3),
  $13::numeric,
  $14::numeric,
  $15::text[],
  $16::bigint
)
RETURNING id
`

type CreateTransactionParams struct {
	EmailId         *string            `json:"emailId"`
	AccountId       int64              `json:"accountId"`
	TxDate          pgtype.Timestamptz `json:"txDate"`
	TxAmount        decimal.Decimal    `json:"txAmount"`
	TxCurrency      string             `json:"txCurrency"`
	TxDirection     string             `json:"txDirection"`
	TxDesc          *string            `json:"txDesc"`
	BalanceAfter    *decimal.Decimal   `json:"balanceAfter"`
	CategoryId      *int64             `json:"categoryId"`
	Merchant        *string            `json:"merchant"`
	UserNotes       *string            `json:"userNotes"`
	ForeignCurrency *string            `json:"foreignCurrency"`
	ForeignAmount   *decimal.Decimal   `json:"foreignAmount"`
	ExchangeRate    *decimal.Decimal   `json:"exchangeRate"`
	Suggestions     []string           `json:"suggestions"`
	ReceiptId       *int64             `json:"receiptId"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.EmailId,
		arg.AccountId,
		arg.TxDate,
		arg.TxAmount,
		arg.TxCurrency,
		arg.TxDirection,
		arg.TxDesc,
		arg.BalanceAfter,
		arg.CategoryId,
		arg.Merchant,
		arg.UserNotes,
		arg.ForeignCurrency,
		arg.ForeignAmount,
		arg.ExchangeRate,
		arg.Suggestions,
		arg.ReceiptId,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteTransactionReturningAccount = `-- name: DeleteTransactionReturningAccount :one
DELETE FROM transactions
WHERE id = $1::bigint
RETURNING account_id
`

func (q *Queries) DeleteTransactionReturningAccount(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, deleteTransactionReturningAccount, id)
	var account_id int64
	err := row.Scan(&account_id)
	return account_id, err
}

const findCandidateTransactions = `-- name: FindCandidateTransactions :many
SELECT
  t.id, t.email_id, t.account_id, t.tx_date, t.tx_amount, t.tx_currency,
  t.tx_direction, t.tx_desc, t.balance_after, t.category_id, t.cat_status,
  t.merchant, t.user_notes, t.suggestions, t.receipt_id,
  t.foreign_currency, t.foreign_amount, t.exchange_rate,
  t.created_at, t.updated_at,
  c.slug  AS category_slug,
  c.label AS category_label,
  c.color AS category_color,
  similarity(t.tx_desc::text, $1::text) AS merchant_score
FROM transactions t
LEFT JOIN categories c ON t.category_id = c.id
WHERE t.receipt_id IS NULL
  AND t.tx_direction = 'outgoing'
  AND t.tx_date >= ($2::date - interval '60 days')
  AND t.tx_amount BETWEEN $3::numeric AND ($3::numeric * 1.20)
  AND similarity(t.tx_desc::text, $1::text) > 0.3
ORDER BY merchant_score DESC
LIMIT 10
`

type FindCandidateTransactionsParams struct {
	Merchant string          `json:"merchant"`
	Date     pgtype.Date     `json:"date"`
	Total    decimal.Decimal `json:"total"`
}

type FindCandidateTransactionsRow struct {
	Id              int64                       `json:"id"`
	EmailId         *string                     `json:"emailId"`
	AccountId       int64                       `json:"accountId"`
	TxDate          pgtype.Timestamptz          `json:"txDate"`
	TxAmount        decimal.Decimal             `json:"txAmount"`
	TxCurrency      string                      `json:"txCurrency"`
	TxDirection     ariand.TransactionDirection `json:"txDirection"`
	TxDesc          *string                     `json:"txDesc"`
	BalanceAfter    *decimal.Decimal            `json:"balanceAfter"`
	CategoryId      *int64                      `json:"categoryId"`
	CatStatus       ariand.CategorizationStatus `json:"catStatus"`
	Merchant        *string                     `json:"merchant"`
	UserNotes       *string                     `json:"userNotes"`
	Suggestions     []string                    `json:"suggestions"`
	ReceiptId       *int64                      `json:"receiptId"`
	ForeignCurrency *string                     `json:"foreignCurrency"`
	ForeignAmount   *decimal.Decimal            `json:"foreignAmount"`
	ExchangeRate    *decimal.Decimal            `json:"exchangeRate"`
	CreatedAt       pgtype.Timestamptz          `json:"createdAt"`
	UpdatedAt       pgtype.Timestamptz          `json:"updatedAt"`
	CategorySlug    *string                     `json:"categorySlug"`
	CategoryLabel   *string                     `json:"categoryLabel"`
	CategoryColor   *string                     `json:"categoryColor"`
	MerchantScore   float32                     `json:"merchantScore"`
}

func (q *Queries) FindCandidateTransactions(ctx context.Context, arg FindCandidateTransactionsParams) ([]FindCandidateTransactionsRow, error) {
	rows, err := q.db.Query(ctx, findCandidateTransactions, arg.Merchant, arg.Date, arg.Total)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCandidateTransactionsRow
	for rows.Next() {
		var i FindCandidateTransactionsRow
		if err := rows.Scan(
			&i.Id,
			&i.EmailId,
			&i.AccountId,
			&i.TxDate,
			&i.TxAmount,
			&i.TxCurrency,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfter,
			&i.CategoryId,
			&i.CatStatus,
			&i.Merchant,
			&i.UserNotes,
			&i.Suggestions,
			&i.ReceiptId,
			&i.ForeignCurrency,
			&i.ForeignAmount,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategorySlug,
			&i.CategoryLabel,
			&i.CategoryColor,
			&i.MerchantScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
SELECT
  t.id, t.email_id, t.account_id, t.tx_date, t.tx_amount, t.tx_currency,
  t.tx_direction, t.tx_desc, t.balance_after, t.category_id, t.cat_status,
  t.merchant, t.user_notes, t.suggestions, t.receipt_id,
  t.foreign_currency, t.foreign_amount, t.exchange_rate,
  t.created_at, t.updated_at,
  c.slug  AS category_slug,
  c.label AS category_label,
  c.color AS category_color
FROM transactions t
LEFT JOIN categories c ON t.category_id = c.id
WHERE t.id = $1::bigint
`

type GetTransactionRow struct {
	Id              int64                       `json:"id"`
	EmailId         *string                     `json:"emailId"`
	AccountId       int64                       `json:"accountId"`
	TxDate          pgtype.Timestamptz          `json:"txDate"`
	TxAmount        decimal.Decimal             `json:"txAmount"`
	TxCurrency      string                      `json:"txCurrency"`
	TxDirection     ariand.TransactionDirection `json:"txDirection"`
	TxDesc          *string                     `json:"txDesc"`
	BalanceAfter    *decimal.Decimal            `json:"balanceAfter"`
	CategoryId      *int64                      `json:"categoryId"`
	CatStatus       ariand.CategorizationStatus `json:"catStatus"`
	Merchant        *string                     `json:"merchant"`
	UserNotes       *string                     `json:"userNotes"`
	Suggestions     []string                    `json:"suggestions"`
	ReceiptId       *int64                      `json:"receiptId"`
	ForeignCurrency *string                     `json:"foreignCurrency"`
	ForeignAmount   *decimal.Decimal            `json:"foreignAmount"`
	ExchangeRate    *decimal.Decimal            `json:"exchangeRate"`
	CreatedAt       pgtype.Timestamptz          `json:"createdAt"`
	UpdatedAt       pgtype.Timestamptz          `json:"updatedAt"`
	CategorySlug    *string                     `json:"categorySlug"`
	CategoryLabel   *string                     `json:"categoryLabel"`
	CategoryColor   *string                     `json:"categoryColor"`
}

func (q *Queries) GetTransaction(ctx context.Context, id int64) (GetTransactionRow, error) {
	row := q.db.QueryRow(ctx, getTransaction, id)
	var i GetTransactionRow
	err := row.Scan(
		&i.Id,
		&i.EmailId,
		&i.AccountId,
		&i.TxDate,
		&i.TxAmount,
		&i.TxCurrency,
		&i.TxDirection,
		&i.TxDesc,
		&i.BalanceAfter,
		&i.CategoryId,
		&i.CatStatus,
		&i.Merchant,
		&i.UserNotes,
		&i.Suggestions,
		&i.ReceiptId,
		&i.ForeignCurrency,
		&i.ForeignAmount,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategorySlug,
		&i.CategoryLabel,
		&i.CategoryColor,
	)
	return i, err
}

const listTransactions = `-- name: ListTransactions :many
SELECT
  t.id, t.email_id, t.account_id, t.tx_date, t.tx_amount, t.tx_currency,
  t.tx_direction, t.tx_desc, t.balance_after, t.category_id, t.cat_status,
  t.merchant, t.user_notes, t.suggestions, t.receipt_id,
  t.foreign_currency, t.foreign_amount, t.exchange_rate,
  t.created_at, t.updated_at,
  c.slug  AS category_slug,
  c.label AS category_label,
  c.color AS category_color
FROM transactions t
LEFT JOIN categories c ON t.category_id = c.id
WHERE TRUE
  AND ($1::timestamptz IS NULL OR $2::bigint IS NULL
       OR (t.tx_date, t.id) < ($1::timestamptz, $2::bigint))
  AND ($3::timestamptz IS NULL OR t.tx_date >= $3::timestamptz)
  AND ($4::timestamptz   IS NULL OR t.tx_date <= $4::timestamptz)
  AND ($5::numeric IS NULL OR t.tx_amount >= $5::numeric)
  AND ($6::numeric IS NULL OR t.tx_amount <= $6::numeric)
  AND ($7::text IS NULL OR t.tx_direction = $7::text)
  AND ($8::bigint[] IS NULL OR t.account_id = ANY($8::bigint[]))
  AND ($9::text[] IS NULL OR c.slug = ANY($9::text[]))
  AND ($10::text IS NULL OR t.merchant ILIKE ('%' || $10::text || '%'))
  AND ($11::text     IS NULL OR t.tx_desc ILIKE ('%' || $11::text || '%'))
  AND ($12::char(3) IS NULL OR t.tx_currency = $12::char(3))
  AND ($13::time IS NULL OR t.tx_date::time >= $13::time)
  AND ($14::time   IS NULL OR t.tx_date::time <= $14::time)
ORDER BY t.tx_date DESC, t.id DESC
`

type ListTransactionsParams struct {
	CursorDate pgtype.Timestamptz `json:"cursorDate"`
	CursorId   *int64             `json:"cursorId"`
	Start      pgtype.Timestamptz `json:"start"`
	End        pgtype.Timestamptz `json:"end"`
	AmountMin  *decimal.Decimal   `json:"amountMin"`
	AmountMax  *decimal.Decimal   `json:"amountMax"`
	Direction  *string            `json:"direction"`
	AccountIds []int64            `json:"accountIds"`
	Categories []string           `json:"categories"`
	MerchantQ  *string            `json:"merchantQ"`
	DescQ      *string            `json:"descQ"`
	Currency   *string            `json:"currency"`
	TodStart   pgtype.Time        `json:"todStart"`
	TodEnd     pgtype.Time        `json:"todEnd"`
}

type ListTransactionsRow struct {
	Id              int64                       `json:"id"`
	EmailId         *string                     `json:"emailId"`
	AccountId       int64                       `json:"accountId"`
	TxDate          pgtype.Timestamptz          `json:"txDate"`
	TxAmount        decimal.Decimal             `json:"txAmount"`
	TxCurrency      string                      `json:"txCurrency"`
	TxDirection     ariand.TransactionDirection `json:"txDirection"`
	TxDesc          *string                     `json:"txDesc"`
	BalanceAfter    *decimal.Decimal            `json:"balanceAfter"`
	CategoryId      *int64                      `json:"categoryId"`
	CatStatus       ariand.CategorizationStatus `json:"catStatus"`
	Merchant        *string                     `json:"merchant"`
	UserNotes       *string                     `json:"userNotes"`
	Suggestions     []string                    `json:"suggestions"`
	ReceiptId       *int64                      `json:"receiptId"`
	ForeignCurrency *string                     `json:"foreignCurrency"`
	ForeignAmount   *decimal.Decimal            `json:"foreignAmount"`
	ExchangeRate    *decimal.Decimal            `json:"exchangeRate"`
	CreatedAt       pgtype.Timestamptz          `json:"createdAt"`
	UpdatedAt       pgtype.Timestamptz          `json:"updatedAt"`
	CategorySlug    *string                     `json:"categorySlug"`
	CategoryLabel   *string                     `json:"categoryLabel"`
	CategoryColor   *string                     `json:"categoryColor"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]ListTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.CursorDate,
		arg.CursorId,
		arg.Start,
		arg.End,
		arg.AmountMin,
		arg.AmountMax,
		arg.Direction,
		arg.AccountIds,
		arg.Categories,
		arg.MerchantQ,
		arg.DescQ,
		arg.Currency,
		arg.TodStart,
		arg.TodEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTransactionsRow
	for rows.Next() {
		var i ListTransactionsRow
		if err := rows.Scan(
			&i.Id,
			&i.EmailId,
			&i.AccountId,
			&i.TxDate,
			&i.TxAmount,
			&i.TxCurrency,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfter,
			&i.CategoryId,
			&i.CatStatus,
			&i.Merchant,
			&i.UserNotes,
			&i.Suggestions,
			&i.ReceiptId,
			&i.ForeignCurrency,
			&i.ForeignAmount,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategorySlug,
			&i.CategoryLabel,
			&i.CategoryColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTransactionReceipt = `-- name: SetTransactionReceipt :execrows
UPDATE transactions
SET receipt_id = $1::bigint
WHERE id = $2::bigint AND receipt_id IS NULL
`

type SetTransactionReceiptParams struct {
	ReceiptId int64 `json:"receiptId"`
	Id        int64 `json:"id"`
}

func (q *Queries) SetTransactionReceipt(ctx context.Context, arg SetTransactionReceiptParams) (int64, error) {
	result, err := q.db.Exec(ctx, setTransactionReceipt, arg.ReceiptId, arg.Id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const syncAccountBalances = `-- name: SyncAccountBalances :exec
WITH transaction_deltas AS (
  SELECT id,
         SUM(CASE WHEN tx_direction = 'incoming' THEN tx_amount ELSE -tx_amount END)
           OVER (PARTITION BY account_id ORDER BY tx_date, id) AS running_delta
  FROM transactions
  WHERE account_id = $1::bigint
),
anchor_point AS (
  SELECT a.anchor_balance,
         COALESCE(SUM(CASE WHEN t.tx_direction = 'incoming' THEN t.tx_amount ELSE -t.tx_amount END), 0.0) AS delta_at_anchor
  FROM accounts a
  LEFT JOIN transactions t ON t.account_id = a.id AND t.tx_date < a.anchor_date
  WHERE a.id = $1::bigint
  GROUP BY a.id, a.anchor_balance
)
UPDATE transactions
SET balance_after = ap.anchor_balance + td.running_delta - ap.delta_at_anchor
FROM transaction_deltas td, anchor_point ap
WHERE transactions.id = td.id
  AND transactions.account_id = $1::bigint
`

func (q *Queries) SyncAccountBalances(ctx context.Context, accountID int64) error {
	_, err := q.db.Exec(ctx, syncAccountBalances, accountID)
	return err
}

const updateTransactionPartial = `-- name: UpdateTransactionPartial :one
UPDATE transactions SET
  email_id         = CASE WHEN $1::bool         THEN $2::text           ELSE email_id         END,
  tx_date          = CASE WHEN $3::bool          THEN $4::timestamptz                 ELSE tx_date          END,
  tx_amount        = CASE WHEN $5::bool        THEN $6::numeric                   ELSE tx_amount        END,
  tx_currency      = CASE WHEN $7::bool      THEN $8::char(3)                 ELSE tx_currency      END,
  tx_direction     = CASE WHEN $9::bool     THEN $10::text                   ELSE tx_direction     END,
  tx_desc          = CASE WHEN $11::bool          THEN $12::text            ELSE tx_desc          END,
  category_id      = CASE WHEN $13::bool      THEN $14::bigint      ELSE category_id      END,
  merchant         = CASE WHEN $15::bool         THEN $16::text           ELSE merchant         END,
  user_notes       = CASE WHEN $17::bool       THEN $18::text         ELSE user_notes       END,
  foreign_currency = CASE WHEN $19::bool THEN $20::char(3) ELSE foreign_currency END,
  foreign_amount   = CASE WHEN $21::bool   THEN $22::numeric  ELSE foreign_amount   END,
  exchange_rate    = CASE WHEN $23::bool    THEN $24::numeric   ELSE exchange_rate    END,
  suggestions      = CASE WHEN $25::bool      THEN $26::text[]      ELSE suggestions      END,
  receipt_id       = CASE WHEN $27::bool       THEN $28::bigint       ELSE receipt_id       END
WHERE id = $29::bigint
RETURNING account_id
`

type UpdateTransactionPartialParams struct {
	EmailIdSet         bool               `json:"emailIdSet"`
	EmailId            *string            `json:"emailId"`
	TxDateSet          bool               `json:"txDateSet"`
	TxDate             pgtype.Timestamptz `json:"txDate"`
	TxAmountSet        bool               `json:"txAmountSet"`
	TxAmount           decimal.Decimal    `json:"txAmount"`
	TxCurrencySet      bool               `json:"txCurrencySet"`
	TxCurrency         string             `json:"txCurrency"`
	TxDirectionSet     bool               `json:"txDirectionSet"`
	TxDirection        string             `json:"txDirection"`
	TxDescSet          bool               `json:"txDescSet"`
	TxDesc             *string            `json:"txDesc"`
	CategoryIdSet      bool               `json:"categoryIdSet"`
	CategoryId         *int64             `json:"categoryId"`
	MerchantSet        bool               `json:"merchantSet"`
	Merchant           *string            `json:"merchant"`
	UserNotesSet       bool               `json:"userNotesSet"`
	UserNotes          *string            `json:"userNotes"`
	ForeignCurrencySet bool               `json:"foreignCurrencySet"`
	ForeignCurrency    *string            `json:"foreignCurrency"`
	ForeignAmountSet   bool               `json:"foreignAmountSet"`
	ForeignAmount      *decimal.Decimal   `json:"foreignAmount"`
	ExchangeRateSet    bool               `json:"exchangeRateSet"`
	ExchangeRate       *decimal.Decimal   `json:"exchangeRate"`
	SuggestionsSet     bool               `json:"suggestionsSet"`
	Suggestions        []string           `json:"suggestions"`
	ReceiptIdSet       bool               `json:"receiptIdSet"`
	ReceiptId          *int64             `json:"receiptId"`
	Id                 int64              `json:"id"`
}

func (q *Queries) UpdateTransactionPartial(ctx context.Context, arg UpdateTransactionPartialParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateTransactionPartial,
		arg.EmailIdSet,
		arg.EmailId,
		arg.TxDateSet,
		arg.TxDate,
		arg.TxAmountSet,
		arg.TxAmount,
		arg.TxCurrencySet,
		arg.TxCurrency,
		arg.TxDirectionSet,
		arg.TxDirection,
		arg.TxDescSet,
		arg.TxDesc,
		arg.CategoryIdSet,
		arg.CategoryId,
		arg.MerchantSet,
		arg.Merchant,
		arg.UserNotesSet,
		arg.UserNotes,
		arg.ForeignCurrencySet,
		arg.ForeignCurrency,
		arg.ForeignAmountSet,
		arg.ForeignAmount,
		arg.ExchangeRateSet,
		arg.ExchangeRate,
		arg.SuggestionsSet,
		arg.Suggestions,
		arg.ReceiptIdSet,
		arg.ReceiptId,
		arg.Id,
	)
	var account_id int64
	err := row.Scan(&account_id)
	return account_id, err
}
