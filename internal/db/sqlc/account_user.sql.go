// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account_user.sql

package sqlcdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addAccountCollaborator = `-- name: AddAccountCollaborator :one
INSERT INTO account_users (account_id, user_id)
SELECT $1::bigint, $2::uuid
FROM accounts a
WHERE a.id = $1::bigint 
  AND a.owner_id = $3::uuid  -- only owners can add collaborators
  AND $2::uuid != $3::uuid  -- can't add yourself
ON CONFLICT DO NOTHING
RETURNING account_id, user_id, added_at
`

type AddAccountCollaboratorParams struct {
	AccountID          int64     `json:"account_id"`
	CollaboratorUserID uuid.UUID `json:"collaborator_user_id"`
	OwnerUserID        uuid.UUID `json:"owner_user_id"`
}

func (q *Queries) AddAccountCollaborator(ctx context.Context, arg AddAccountCollaboratorParams) (AccountUser, error) {
	row := q.db.QueryRow(ctx, addAccountCollaborator, arg.AccountID, arg.CollaboratorUserID, arg.OwnerUserID)
	var i AccountUser
	err := row.Scan(&i.AccountID, &i.UserID, &i.AddedAt)
	return i, err
}

const checkAccountCollaborator = `-- name: CheckAccountCollaborator :one
SELECT EXISTS(
  SELECT 1 FROM account_users au
  JOIN accounts a ON au.account_id = a.id
  WHERE au.account_id = $1::bigint
    AND au.user_id = $2::uuid
    OR a.owner_id = $2::uuid
) AS is_collaborator
`

type CheckAccountCollaboratorParams struct {
	AccountID int64     `json:"account_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) CheckAccountCollaborator(ctx context.Context, arg CheckAccountCollaboratorParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAccountCollaborator, arg.AccountID, arg.UserID)
	var is_collaborator bool
	err := row.Scan(&is_collaborator)
	return is_collaborator, err
}

const getAccountCollaboratorCount = `-- name: GetAccountCollaboratorCount :one
SELECT COUNT(*) AS collaborator_count
FROM account_users
WHERE account_id = $1::bigint
`

func (q *Queries) GetAccountCollaboratorCount(ctx context.Context, accountID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getAccountCollaboratorCount, accountID)
	var collaborator_count int64
	err := row.Scan(&collaborator_count)
	return collaborator_count, err
}

const leaveAccountCollaboration = `-- name: LeaveAccountCollaboration :execrows
DELETE FROM account_users
WHERE account_id = $1::bigint
  AND user_id = $2::uuid
`

type LeaveAccountCollaborationParams struct {
	AccountID int64     `json:"account_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) LeaveAccountCollaboration(ctx context.Context, arg LeaveAccountCollaborationParams) (int64, error) {
	result, err := q.db.Exec(ctx, leaveAccountCollaboration, arg.AccountID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listAccountCollaborators = `-- name: ListAccountCollaborators :many
SELECT u.id, u.email, u.display_name, au.added_at
FROM account_users au
JOIN users u ON u.id = au.user_id
JOIN accounts a ON a.id = au.account_id
WHERE au.account_id = $1::bigint
  AND (a.owner_id = $2::uuid OR au.user_id = $2::uuid)
ORDER BY u.email
`

type ListAccountCollaboratorsParams struct {
	AccountID        int64     `json:"account_id"`
	RequestingUserID uuid.UUID `json:"requesting_user_id"`
}

type ListAccountCollaboratorsRow struct {
	ID          uuid.UUID `json:"id"`
	Email       string    `json:"email"`
	DisplayName *string   `json:"display_name"`
	AddedAt     time.Time `json:"added_at"`
}

func (q *Queries) ListAccountCollaborators(ctx context.Context, arg ListAccountCollaboratorsParams) ([]ListAccountCollaboratorsRow, error) {
	rows, err := q.db.Query(ctx, listAccountCollaborators, arg.AccountID, arg.RequestingUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountCollaboratorsRow
	for rows.Next() {
		var i ListAccountCollaboratorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.DisplayName,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserCollaborations = `-- name: ListUserCollaborations :many
SELECT 
  a.id AS account_id, 
  a.name AS account_name, 
  a.bank, 
  au.added_at,
  u.email AS owner_email,
  u.display_name AS owner_name
FROM account_users au
JOIN accounts a ON au.account_id = a.id
JOIN users u ON a.owner_id = u.id
WHERE au.user_id = $1::uuid
ORDER BY au.added_at DESC
`

type ListUserCollaborationsRow struct {
	AccountID   int64     `json:"account_id"`
	AccountName string    `json:"account_name"`
	Bank        string    `json:"bank"`
	AddedAt     time.Time `json:"added_at"`
	OwnerEmail  string    `json:"owner_email"`
	OwnerName   *string   `json:"owner_name"`
}

func (q *Queries) ListUserCollaborations(ctx context.Context, userID uuid.UUID) ([]ListUserCollaborationsRow, error) {
	rows, err := q.db.Query(ctx, listUserCollaborations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserCollaborationsRow
	for rows.Next() {
		var i ListUserCollaborationsRow
		if err := rows.Scan(
			&i.AccountID,
			&i.AccountName,
			&i.Bank,
			&i.AddedAt,
			&i.OwnerEmail,
			&i.OwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAccountCollaborator = `-- name: RemoveAccountCollaborator :execrows
DELETE FROM account_users
WHERE account_id = $1::bigint
  AND user_id = $2::uuid
  AND EXISTS (
    SELECT 1 FROM accounts a 
    WHERE a.id = $1::bigint 
      AND a.owner_id = $3::uuid
  )
`

type RemoveAccountCollaboratorParams struct {
	AccountID          int64     `json:"account_id"`
	CollaboratorUserID uuid.UUID `json:"collaborator_user_id"`
	OwnerUserID        uuid.UUID `json:"owner_user_id"`
}

func (q *Queries) RemoveAccountCollaborator(ctx context.Context, arg RemoveAccountCollaboratorParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeAccountCollaborator, arg.AccountID, arg.CollaboratorUserID, arg.OwnerUserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removeUserFromAllAccounts = `-- name: RemoveUserFromAllAccounts :execrows
DELETE FROM account_users
WHERE user_id = $1::uuid
`

func (q *Queries) RemoveUserFromAllAccounts(ctx context.Context, userID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, removeUserFromAllAccounts, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const transferAccountOwnership = `-- name: TransferAccountOwnership :execrows
UPDATE accounts
SET owner_id = $1::uuid
WHERE id = $2::bigint 
  AND owner_id = $3::uuid
  AND EXISTS (
    SELECT 1 FROM account_users 
    WHERE account_id = $2::bigint 
      AND user_id = $1::uuid
  )
`

type TransferAccountOwnershipParams struct {
	NewOwnerID     uuid.UUID `json:"new_owner_id"`
	AccountID      int64     `json:"account_id"`
	CurrentOwnerID uuid.UUID `json:"current_owner_id"`
}

func (q *Queries) TransferAccountOwnership(ctx context.Context, arg TransferAccountOwnershipParams) (int64, error) {
	result, err := q.db.Exec(ctx, transferAccountOwnership, arg.NewOwnerID, arg.AccountID, arg.CurrentOwnerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
