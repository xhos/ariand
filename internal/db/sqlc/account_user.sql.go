// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account_user.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addAccountCollaborator = `-- name: AddAccountCollaborator :one
insert into
  account_users (account_id, user_id)
select
  $1::bigint,
  $2::uuid
from
  accounts a
where
  a.id = $1::bigint
  and a.owner_id = $3::uuid -- only owners can add collaborators
  and $2::uuid != $3::uuid -- can't add yourself
  on CONFLICT do NOTHING
returning
  account_id,
  user_id,
  added_at
`

type AddAccountCollaboratorParams struct {
	AccountID          int64     `json:"account_id"`
	CollaboratorUserID uuid.UUID `json:"collaborator_user_id"`
	OwnerUserID        uuid.UUID `json:"owner_user_id"`
}

func (q *Queries) AddAccountCollaborator(ctx context.Context, arg AddAccountCollaboratorParams) (AccountUser, error) {
	row := q.db.QueryRow(ctx, addAccountCollaborator, arg.AccountID, arg.CollaboratorUserID, arg.OwnerUserID)
	var i AccountUser
	err := row.Scan(&i.AccountID, &i.UserID, &i.AddedAt)
	return i, err
}

const checkAccountCollaborator = `-- name: CheckAccountCollaborator :one
select
  exists(
    select
      1
    from
      account_users au
      join accounts a on au.account_id = a.id
    where
      au.account_id = $1::bigint
      and au.user_id = $2::uuid
      or a.owner_id = $2::uuid
  ) as is_collaborator
`

type CheckAccountCollaboratorParams struct {
	AccountID int64     `json:"account_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) CheckAccountCollaborator(ctx context.Context, arg CheckAccountCollaboratorParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAccountCollaborator, arg.AccountID, arg.UserID)
	var is_collaborator bool
	err := row.Scan(&is_collaborator)
	return is_collaborator, err
}

const getAccountCollaboratorCount = `-- name: GetAccountCollaboratorCount :one
select
  COUNT(*) as collaborator_count
from
  account_users
where
  account_id = $1::bigint
`

func (q *Queries) GetAccountCollaboratorCount(ctx context.Context, accountID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getAccountCollaboratorCount, accountID)
	var collaborator_count int64
	err := row.Scan(&collaborator_count)
	return collaborator_count, err
}

const leaveAccountCollaboration = `-- name: LeaveAccountCollaboration :execrows
delete from
  account_users
where
  account_id = $1::bigint
  and user_id = $2::uuid
`

type LeaveAccountCollaborationParams struct {
	AccountID int64     `json:"account_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) LeaveAccountCollaboration(ctx context.Context, arg LeaveAccountCollaborationParams) (int64, error) {
	result, err := q.db.Exec(ctx, leaveAccountCollaboration, arg.AccountID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listAccountCollaborators = `-- name: ListAccountCollaborators :many
select
  u.id,
  u.email,
  u.display_name,
  au.added_at
from
  account_users au
  join users u on u.id = au.user_id
  join accounts a on a.id = au.account_id
where
  au.account_id = $1::bigint
  and (
    a.owner_id = $2::uuid
    or au.user_id = $2::uuid
  )
order by
  u.email
`

type ListAccountCollaboratorsParams struct {
	AccountID        int64     `json:"account_id"`
	RequestingUserID uuid.UUID `json:"requesting_user_id"`
}

type ListAccountCollaboratorsRow struct {
	ID          uuid.UUID `json:"id"`
	Email       string    `json:"email"`
	DisplayName *string   `json:"display_name"`
	AddedAt     time.Time `json:"added_at"`
}

func (q *Queries) ListAccountCollaborators(ctx context.Context, arg ListAccountCollaboratorsParams) ([]ListAccountCollaboratorsRow, error) {
	rows, err := q.db.Query(ctx, listAccountCollaborators, arg.AccountID, arg.RequestingUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountCollaboratorsRow
	for rows.Next() {
		var i ListAccountCollaboratorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.DisplayName,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserCollaborations = `-- name: ListUserCollaborations :many
select
  a.id as account_id,
  a.name as account_name,
  a.bank,
  au.added_at,
  u.email as owner_email,
  u.display_name as owner_name
from
  account_users au
  join accounts a on au.account_id = a.id
  join users u on a.owner_id = u.id
where
  au.user_id = $1::uuid
order by
  au.added_at desc
`

type ListUserCollaborationsRow struct {
	AccountID   int64     `json:"account_id"`
	AccountName string    `json:"account_name"`
	Bank        string    `json:"bank"`
	AddedAt     time.Time `json:"added_at"`
	OwnerEmail  string    `json:"owner_email"`
	OwnerName   *string   `json:"owner_name"`
}

func (q *Queries) ListUserCollaborations(ctx context.Context, userID uuid.UUID) ([]ListUserCollaborationsRow, error) {
	rows, err := q.db.Query(ctx, listUserCollaborations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserCollaborationsRow
	for rows.Next() {
		var i ListUserCollaborationsRow
		if err := rows.Scan(
			&i.AccountID,
			&i.AccountName,
			&i.Bank,
			&i.AddedAt,
			&i.OwnerEmail,
			&i.OwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAccountCollaborator = `-- name: RemoveAccountCollaborator :execrows
delete from
  account_users
where
  account_id = $1::bigint
  and user_id = $2::uuid
  and exists (
    select
      1
    from
      accounts a
    where
      a.id = $1::bigint
      and a.owner_id = $3::uuid
  )
`

type RemoveAccountCollaboratorParams struct {
	AccountID          int64     `json:"account_id"`
	CollaboratorUserID uuid.UUID `json:"collaborator_user_id"`
	OwnerUserID        uuid.UUID `json:"owner_user_id"`
}

func (q *Queries) RemoveAccountCollaborator(ctx context.Context, arg RemoveAccountCollaboratorParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeAccountCollaborator, arg.AccountID, arg.CollaboratorUserID, arg.OwnerUserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removeUserFromAllAccounts = `-- name: RemoveUserFromAllAccounts :execrows
delete from
  account_users
where
  user_id = $1::uuid
`

func (q *Queries) RemoveUserFromAllAccounts(ctx context.Context, userID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, removeUserFromAllAccounts, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const transferAccountOwnership = `-- name: TransferAccountOwnership :execrows
update
  accounts
set
  owner_id = $1::uuid
where
  id = $2::bigint
  and owner_id = $3::uuid
  and exists (
    select
      1
    from
      account_users
    where
      account_id = $2::bigint
      and user_id = $1::uuid
  )
`

type TransferAccountOwnershipParams struct {
	NewOwnerID     uuid.UUID `json:"new_owner_id"`
	AccountID      int64     `json:"account_id"`
	CurrentOwnerID uuid.UUID `json:"current_owner_id"`
}

func (q *Queries) TransferAccountOwnership(ctx context.Context, arg TransferAccountOwnershipParams) (int64, error) {
	result, err := q.db.Exec(ctx, transferAccountOwnership, arg.NewOwnerID, arg.AccountID, arg.CurrentOwnerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
